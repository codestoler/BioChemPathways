<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metabolic Pathway</title>
    
    <style>
        /* === å…¨å±€æ ·å¼ === */
        body {
            font-family: "Microsoft YaHei", "Segoe UI", sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background-color: #f8f9fa;
        }

                /* === é¡¶éƒ¨å¯¼èˆªæ  === */
        header.topbar{
            background-color: #fff;
            padding: 12px 18px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            display: grid;
            grid-template-columns: auto 1fr auto;
            align-items: center;
            gap: 14px;
            z-index: 10;
        }

        .brand{
            display:flex;
            align-items:center;
            gap:10px;
            min-width: 0;
        }
        .brand-emoji{ font-size: 20px; }
        .brand-title{
            font-size: 20px;
            font-weight: 700;
            color:#111827;
            letter-spacing: 0.2px;
            white-space: nowrap;
        }

        .topbar-center{
            display:flex;
            align-items:center;
            gap: 10px;
            flex-wrap: wrap;
            min-width: 0;
            justify-content: center;
        }

        .chip{
            display:flex;
            align-items:center;
            gap: 8px;
            padding: 8px 10px;
            border: 1px solid #edf0f5;
            background: #f6f7fb;
            border-radius: 14px;
            min-width: 0;
        }
        .chip-icon{ font-size: 14px; opacity: 0.9; }
        .chip-label{
            font-size: 12px;
            color:#4b5563;
            font-weight: 600;
            letter-spacing: 0.2px;
        }
        .chip-arrow{ color:#6b7280; user-select:none; }
        .chip-hint{
            font-size: 12px;
            color:#6b7280;
            white-space: nowrap;
            max-width: 220px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .chip input{
            border: none;
            background: transparent;
            outline: none;
            font-size: 13px;
            color:#111827;
            min-width: 0;
        }
        .search-chip input{ width: 220px; }
        .path-chip input{ width: 140px; }

/* Make Path chip wrap so right-side icons (Freeze/Save) remain visible on narrow screens */
.path-chip{ flex-wrap: wrap; align-content: center; }
.path-chip .chip-label{ flex: 0 0 100%; margin-bottom: 2px; font-weight: 600; }
.path-chip input{ width: auto; flex: 1 1 160px; min-width: 130px; }
.path-chip .chip-arrow{ flex: 0 0 auto; }
.path-chip #path-find-btn, .path-chip #path-clear-btn{ flex: 0 0 auto; }
.path-chip .chip-hint{ flex: 0 0 100%; }

        .topbar-actions{
            display:flex;
            align-items:center;
            gap: 10px;
            justify-content: flex-end;
        }

        .btn{
            cursor:pointer;
            padding: 8px 10px;
            border: 1px solid #e2e6ef;
            background:#fff;
            border-radius: 14px;
            font-size: 13px;
            color:#111827;
            display:flex;
            align-items:center;
            gap:6px;
            white-space: nowrap;
            user-select: none;
        }
        .btn:hover{ background:#f6f7fb; }

        .btn-primary{
            background:#111827;
            color:#fff;
            border-color:#111827;
        }
        .btn-primary:hover{ background:#0b1220; }

        #freeze-toggle.is-on{
            border-color:#f59e0b;
            background:#fff7ed;
        }

        .status{
            font-size: 12px;
            color: #6b7280;
            max-width: 220px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* é”™è¯¯æç¤º */
        #error-msg {
            grid-column: 1 / -1;
            color: #d32f2f;
            background: #ffebee;
            padding: 6px 10px;
            border-radius: 10px;
            font-size: 12px;
            display: none;
        }

        @media (max-width: 980px){
            header.topbar{
                grid-template-columns: 1fr;
                align-items: stretch;
            }
            .topbar-actions{
                justify-content: space-between;
            }
            .search-chip input{ width: 180px; }
            .path-chip input{ width: 120px; }
        }

/* åœ¨ <style> ä¸­ */
    #search-sidebar {
    width: 420px;
    max-width: 45vw;
    min-width: 320px;
    background: #fff;
    border-left: 1px solid #ddd;
    padding: 20px;
    overflow-y: auto;
    /* åˆ é™¤ display: flex; è¿™ä¸€è¡Œï¼Œè®©å®ƒé»˜è®¤éµå¾ª HTML é‡Œçš„ style="display:none" */
    /* æˆ–è€…ä¿ç•™ display: flex ä½†ä¾èµ– JS è¦†ç›– inline styleï¼Œé€šå¸¸æ²¡é—®é¢˜ï¼Œä½†åˆ é™¤æ›´ä¿é™© */
    flex-direction: column;
    box-shadow: -2px 0 5px rgba(0,0,0,0.05);
    transition: all 0.3s ease;

    }

        /* å•ä¸ªResultså¡ç‰‡ */
        .result-item {
            padding: 10px;
            margin-bottom: 8px;
            background: #fff;
            border: 1px solid #eee;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .result-item:hover {
            background-color: #f0f7ff;
            border-color: #2196F3;
            transform: translateX(-3px); /* æ‚¬åœæ—¶å¾®åŠ¨æ•ˆæœ */
            box-shadow: 2px 2px 5px rgba(0,0,0,0.05);
        }

        .result-name {
            font-size: 14px;
            font-weight: bold;
            color: #333;
            margin-bottom: 4px;
        }

        .result-pathway {
            font-size: 11px;
            color: #666;
            background: #f1f2f6;
            padding: 2px 6px;
            border-radius: 4px;
            display: inline-block;
        }
        
        .result-type-tag {
            font-size: 10px;
            padding: 2px 4px;
            border-radius: 3px;
            margin-left: 5px;
            color: #fff;
        }

        /* æ§åˆ¶æ§ä»¶ */
        .controls { display: flex; align-items: center; gap: 10px; }
        .status { font-size: 12px; color: #666; }
        
        /* é”™è¯¯æç¤º */
        #error-msg {
            color: #d32f2f;
            background: #ffebee;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            display: none;
        }

        /* === å†…å®¹åŒºåŸŸ === */
        #main-container {
            flex: 1;
            display: flex;
            overflow: hidden; /* é˜²æ­¢åŒæ»šåŠ¨æ¡ */
        }

        /* å·¦ä¾§ä¾§è¾¹æ ï¼šç­›é€‰å™¨ */
        #sidebar {
            width: 260px;
            background: #fff;
            border-right: 1px solid #eee;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        .sidebar-title {
            font-size: 14px; font-weight: bold; color: #555;
            margin-bottom: 15px; text-transform: uppercase; letter-spacing: 1px;
        }
        
        /* Pathway å¤é€‰æ¡† */
        .pathway-list { display: flex; flex-direction: column; gap: 8px; }
        .checkbox-item {
            display: flex; align-items: center;
            cursor: pointer; font-size: 13px; color: #444;
            padding: 5px; border-radius: 4px; transition: background 0.2s;
        }
        .checkbox-item:hover { background: #f0f7ff; }
        
        .side-action-btn{
            margin: 6px 0 10px 0;
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: #fff;
            cursor: pointer;
            font-size: 12px;
            color: #444;
        }
        .side-action-btn:hover{ background: #f6f6f6; }

        .pw-text{ flex: 1; margin-left: 6px; min-width: 0; padding-right: 10px; line-height: 1.2; }
        .side-toggle-btn{
            margin-left: auto;
            padding: 4px 10px;
            border: 1px solid #ddd;
            border-radius: 999px;
            background: #fff;
            cursor: pointer;
            font-size: 11px;
            color: #444;
            white-space: nowrap;
            flex-shrink: 0;
        }
        .side-toggle-btn:hover{ background: #f6f6f6; }
        .side-toggle-btn.active{
            background: #efefef;
            font-weight: 600;
        }
.checkbox-item input { margin-right: 10px; accent-color: #2196F3; }

        /* åˆ†ç»„ Pathway åˆ—è¡¨ */
        .sheet-group { margin-top: 12px; padding-top: 8px; border-top: 1px solid #eee; }
        .sheet-header { display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom: 6px; }
        .sheet-name { display:flex; align-items:center; gap:6px; font-size: 12px; font-weight: bold; color:#333; }
        .sheet-swatch { width:10px; height:10px; border-radius: 3px; }
        .sheet-selectall { font-size: 12px; margin: 0; padding: 0; }
        .sheet-body { display:flex; flex-direction:column; gap:6px; margin-left: 10px; }

        /* å³ä¾§ç»˜å›¾åŒº */
        #graph-area {
            flex: 1;
            position: relative;
            background: #f8f9fa;
            /* Ensure z-index ordering is stable even if Cytoscape injects canvases */
            isolation: isolate;
        }
        /* Cytoscape network stays BELOW the organelle overlay */
        #cy {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            z-index: 1 !important;
        }

        /* Force Cytoscape renderer surfaces to stay under our overlay */
        #cy canvas,
        #cy svg {
            position: absolute;
            inset: 0;
            z-index: 1 !important;
        }

        /* === Organelle overlay layer (synced with Cytoscape world coords) === */
        #organelle-layer{
            position:absolute;
            inset:0;
            z-index: 9999 !important;   /* ALWAYS float above the network */
            overflow:hidden;
            pointer-events:none;        /* default: do not block the network */
            /* keep colors stable; transparency is controlled via opacity */
            mix-blend-mode: normal;
            will-change: transform;
            transform-style: preserve-3d;
            -webkit-transform-style: preserve-3d;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }
        #organelle-layer.editing{
            z-index: 10000 !important;
            pointer-events:auto;        /* allow drag/resize/rotate */
        }
        .organelle-box{
            position:absolute;
            box-sizing:border-box;
            border: 2px dashed rgba(80,90,110,0.35);
            border-radius: 14px;
            display:flex;
            align-items:center;
            justify-content:center;
            user-select:none;
            touch-action:none;
            background: transparent;
        }
        .organelle-box.editing.selected{
            border-color: rgba(0,120,255,0.65);
            background: rgba(0,120,255,0.04);
        }
        .organelle-box:not(.editing){
            border:none;
            background: transparent;
        }
        .organelle-box img{
            width:100%;
            height:100%;
            object-fit:contain;
            opacity:0.18;
            filter: saturate(0.95);
            pointer-events:none;        /* drag is handled by the box */
            transform: rotate(var(--rot, 0deg));
            transform-origin: 50% 50%;
        }
        .organelle-handle{
            position:absolute;
            width:14px;
            height:14px;
            right:-7px;
            bottom:-7px;
            border-radius:6px;
            background: rgba(30,40,55,0.75);
            border:2px solid rgba(255,255,255,0.9);
            cursor: nwse-resize;
            display:none;
        }
        .organelle-rotate-handle{
            position:absolute;
            width:16px;
            height:16px;
            top:-20px;
            left:50%;
            transform: translateX(-50%);
            border-radius: 999px;
            background: rgba(30,40,55,0.75);
            border:2px solid rgba(255,255,255,0.9);
            cursor: grab;
            display:none;
        }
        .organelle-rotate-handle:active{ cursor: grabbing; }
        .organelle-box.editing .organelle-handle{ display:block; }
        .organelle-box.editing .organelle-rotate-handle{ display:block; }

        .organelle-panel{
            position:absolute;
            top: 14px;
            right: 14px;
            z-index: 30;
            width: 320px;
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(6px);
            border: 1px solid rgba(0,0,0,0.08);
            border-radius: 16px;
            padding: 12px 12px 10px 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.12);
            font-size: 13px;
            color:#334;
        }
        .organelle-panel-title{
            font-weight: 700;
            margin-bottom: 10px;
        }
        .organelle-panel-row{
            display:flex;
            align-items:center;
            gap:10px;
            margin-bottom: 10px;
        }
        .organelle-panel-row input[type="range"]{
            flex:1;
        }
        .organelle-panel-hint{
            font-size: 12px;
            color: #667;
            line-height: 1.35;
        }


        /* åŠ è½½é®ç½© */
        #loading {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255,255,255,0.8);
            display: flex; justify-content: center; align-items: center;
            font-size: 16px; color: #666;
            z-index: 20;
        }
    
        .chip-clear{
            border: none;
            background: transparent;
            cursor: pointer;
            width: 22px;
            height: 22px;
            line-height: 22px;
            text-align: center;
            border-radius: 999px;
            font-size: 16px;
            color: #64748b;
            display: none;
            flex: 0 0 auto;
        }
        .chip-clear:hover{
            background: rgba(148,163,184,0.18);
            color: #334155;
        }
        .chip.has-value .chip-clear{ display: inline-flex; align-items: center; justify-content: center; }

        #freeze-toggle{ min-width: 118px; }

    </style>
</head>
<body>
    <!-- 1. åŠ è½½é®ç½©å±‚ -->
    <div id="loading-mask" style="position: fixed; top:0; left:0; width:100%; height:100%; background: rgba(255,255,255,0.95); z-index: 9999; display: flex; flex-direction: column; justify-content: center; align-items: center;">
        <h2 style="color: #333;">Loading...</h2>
        <div style="width: 300px; height: 10px; background: #eee; border-radius: 5px; overflow: hidden; margin-top: 10px;">
            <div id="progress-bar" style="width: 0%; height: 100%; background: #0984e3; transition: width 0.1s;"></div>
        </div>
        <p id="progress-text" style="margin-top: 10px; color: #666; font-size: 14px;">Preparing data...</p>
    </div>

    <!-- 2. é¡¶éƒ¨å¯¼èˆªæ  -->
    <header class="topbar">
        <div class="brand" title="Metabolic Pathway">
            <span class="brand-emoji">ğŸŒ±</span>
            <span class="brand-title">Metabolic Pathway</span>
        </div>

        <div class="topbar-center">
            <div class="chip search-chip">
                <span class="chip-icon">ğŸ”</span>
                <input type="text" id="search-input" placeholder="Search molecule (e.g., ATP)..." />
                <button id="search-clear-btn" type="button" class="chip-clear" title="Clear search" aria-label="Clear search">Ã—</button>
                <span id="search-status" class="chip-hint"></span>
            </div>

            <div class="chip path-chip">
                <span class="chip-label">Path</span>
                <input type="text" id="path-start-input" placeholder="Start molecule" />
                <span class="chip-arrow">â†’</span>
                <input type="text" id="path-end-input" placeholder="End molecule" />
                <button id="path-find-btn" type="button" class="btn btn-ghost">ğŸ§¬ Find path</button>
                <button id="path-clear-btn" type="button" class="chip-clear" title="Clear path search" aria-label="Clear path search">Ã—</button>
                <span id="path-status" class="chip-hint"></span>
            </div>
        </div>

        <div class="topbar-actions">
            <button id="freeze-toggle" type="button" class="btn btn-ghost" title="Freeze/unfreeze node dragging">ğŸ”’ Freeze</button>
            <button id="save-layout-btn" type="button" class="btn btn-primary" title="Save current layout">ğŸ’¾ Save layout</button>
            <button id="organelle-toggle-btn" type="button" class="btn btn-ghost" title="Adjust organelle background images">ğŸ§« Organelles</button>
            <span id="status" class="status"></span>
        </div>

        <div id="error-msg"></div>
    </header>

    <!-- 3. ä¸»å†…å®¹åŒºåŸŸ (æ ¸å¿ƒä¿®æ”¹ï¼šç¡®ä¿åªæœ‰ä¸€ä¸ª clean çš„ container) -->
    <div id="main-container">
        
        <!-- å·¦ä¾§ï¼šç­›é€‰æ§åˆ¶ -->
        <div id="sidebar">
            <div class="sidebar-title">Pathway Select</div>
            <div id="filter-container" class="pathway-list">
                <div style="color:#999; font-style:italic;">No data yet</div>
            </div>
            
            <div style="margin-top:20px; font-size:10px; color:#999; line-height:1.5;">
                <hr style="border:0; border-top:1px solid #eee; margin:10px 0;">
                <p>ğŸ’¡ <b>Legend:</b></p>
                <p><span style="color:#2ecc71">â—</span>  Main substrate</p>
                <p><span style="color:#74b9ff">â—</span>  Other Reactant</p>
                <p><span style="color:#a29bfe">â—</span>  Other Product</p>
                <p><span style="border:1px solid #55efc4; border-radius:50%; display:inline-block; width:8px; height:8px;"></span> Hollow: enzyme/reaction node</p>
            </div>
        </div>

        <!-- ä¸­é—´ï¼šCytoscape ç”»å¸ƒ -->
        <div id="graph-area">
            <div id="loading" style="display:none;">Working...</div>
            <div id="organelle-panel" class="organelle-panel" style="display:none;">
                <div class="organelle-panel-title">Organelles</div>
                
                <div class="organelle-panel-row">
                    <label style="min-width:70px;">Selected</label>
                    <span id="organelle-selected-label" style="flex:1; font-weight:600; color:#334;">None</span>
                </div>
                <div class="organelle-panel-row">
                    <label style="min-width:70px;">Opacity</label>
                    <input id="organelle-opacity" type="range" min="0" max="100" value="18" />
                    <span id="organelle-opacity-val" style="min-width:34px; text-align:right;">18%</span>
                </div>
                <div class="organelle-panel-row">
                    <label style="min-width:70px;">Rotate</label>
                    <input id="organelle-rotate" type="range" min="-180" max="180" value="0" />
                    <span id="organelle-rotate-val" style="min-width:48px; text-align:right;">0Â°</span>
                </div>
                <div class="organelle-panel-row">
                    <button id="organelle-reset-btn" type="button" class="btn btn-ghost">Reset</button>
                    <button id="organelle-save-btn" type="button" class="btn btn-primary">Save</button>
                    <button id="organelle-done-btn" type="button" class="btn btn-ghost">Done</button>
                </div>
                <div class="organelle-panel-hint">ç¼–è¾‘æ¨¡å¼ä¸‹ï¼šæ‹–æ‹½ç§»åŠ¨ï¼›å³ä¸‹è§’æŠŠæ‰‹ç¼©æ”¾ï¼›ä¸Šæ–¹åœ†ç‚¹æ—‹è½¬ã€‚ç‚¹ Done é€€å‡ºç¼–è¾‘åï¼Œå›¾ç‰‡ä»ä¼šåŠé€æ˜æµ®åœ¨ç½‘ç»œä¸Šæ–¹ï¼Œä½†ä¸ä¼šæŒ¡ä½èŠ‚ç‚¹ç‚¹å‡»ã€‚</div>

            </div>
            <div id="cy"></div>
            <!-- Overlay organelles AFTER #cy so DOM order also guarantees it sits on top -->
            <div id="organelle-layer" aria-hidden="true"></div>
        </div>

        <!-- å³ä¾§ï¼šResultsæ  (é»˜è®¤éšè—) -->
        <div id="search-sidebar" style="display: none;">
            <div class="sidebar-title" style="display:flex; justify-content:space-between; align-items:center;">
                <span>Results (<span id="result-count">0</span>)</span>
                <!-- å…³é—­æŒ‰é’® -->
                <button onclick="closeAllPanels()" style="border:none; background:none; cursor:pointer; font-size:18px; color:#999;">&times;</button>
            </div>
            <div id="search-results-list" class="pathway-list">
                <!-- JS ä¼šåœ¨è¿™é‡Œæ’å…¥ .result-item -->
            </div>
        </div>

    </div>

    


    <!-- è„šæœ¬åº“ (Staticfile CDN) -->
    <script src="https://cdn.staticfile.org/cytoscape/3.23.0/cytoscape.min.js"></script>
    <script src="https://cdn.staticfile.org/dagre/0.8.5/dagre.min.js"></script>
    <script src="https://unpkg.com/cytoscape-dagre@2.4.0/cytoscape-dagre.js"></script>

<script>
    // ================= é…ç½®åŒºåŸŸ =================
    // åœ¨æ­¤å¤„è¾“å…¥ä½ æƒ³åˆå¹¶æ˜¾ç¤ºçš„ Sheet åç§°
    const TARGET_SHEETS = ["Carbonhydrates", "Lipids", "Proteins", "Nucleotides"];

    // ä¸»é¢˜è‰²ï¼šä¸åŒ sheet çš„ä¸»ååº”ç‰©/ä¸»äº§ç‰©
    const SHEET_COLORS = {
        Carbonhydrates: "#E699A7",
        Lipids: "#FEDD9E",
        Proteins: "#A6D9C0",
        Nucleotides: "#71A7D2"
    };
    // é¢œè‰²ä¼˜å…ˆçº§ï¼šè‹¥åŒä¸€åˆ†å­å‡ºç°åœ¨å¤šä¸ª sheetsï¼ŒæŒ‰æ­¤é¡ºåºå–è‰²
    const SHEET_PRIORITY = ["Carbonhydrates", "Lipids", "Proteins", "Nucleotides"];

    // ====== Side-molecule visibility state ======
    // é€‰ä¸­çš„â€œEnzyme/Reactionâ€é›†åˆï¼šç‚¹é€‰å¤šä¸ªååº”æ—¶ï¼Œå°åˆ†å­ä¸ä¼šæ¶ˆå¤±
    window.selectedReactionIds = new Set();
    // è¢«â€œDemonstrate currencyâ€æŒ‰é’®å›ºå®šæ‰“å¼€çš„å°åˆ†å­ï¼šæŒ‰ pathway ç»´åº¦
    window.pinnedSidePathways = new Set();
    // å½“å‰ pathway å‹¾é€‰çŠ¶æ€ï¼ˆç”¨äº side-molecule çš„æ˜¾ç¤ºè£å‰ªï¼‰
    window.__selectedPathwaysSet = new Set();


    function toTitleCase(str) {
        if (!str) return str;
        return String(str)
            .trim()
            .split(/\s+/)
            .map(w => w.split('-').map(p => p ? (p[0].toUpperCase() + p.slice(1)) : p).join('-'))
            .join(' ');
    }


    function pickSheetColor(sheetSet) {
        if (!sheetSet) return "#95a5a6";
        for (const s of SHEET_PRIORITY) {
            if (sheetSet.has(s)) return SHEET_COLORS[s];
        }
        return "#95a5a6";
    }

// ===========================================

    // å®šä¹‰ä¸€ä¸ª Keyï¼Œç”¨äºåœ¨æµè§ˆå™¨ç¼“å­˜ä¸­å­˜å‚¨æ•°æ®
    const STORAGE_KEY = 'metabolic_pathway_positions_v1';
    // ============================================================
    // UI: Freeze / Unfreeze node dragging
    // - Frozen: nodes cannot be dragged, but can still be clicked/selected
    // - Unfrozen: nodes can be freely arranged
    // ============================================================
    window.__uiFrozen = (localStorage.getItem('metabolic_ui_frozen') === '1');

    function applyFrozenState() {
        const btn = document.getElementById('freeze-toggle');
        if (btn) {
            btn.textContent = window.__uiFrozen ? 'ğŸ”“ Unfreeze' : 'ğŸ”’ Freeze';
            btn.classList.toggle('is-on', window.__uiFrozen);
        }
        if (window.cyGraph) {
            // disable/enable dragging only (still allows click, pan, zoom)
            window.cyGraph.autoungrabify(!!window.__uiFrozen);
        }
    }

    function toggleFrozen() {
        window.__uiFrozen = !window.__uiFrozen;
        localStorage.setItem('metabolic_ui_frozen', window.__uiFrozen ? '1' : '0');
        applyFrozenState();
        }

    // bind once after DOM ready
    document.addEventListener('DOMContentLoaded', () => {
        const btn = document.getElementById('freeze-toggle');
        if (btn) btn.addEventListener('click', toggleFrozen);

        const saveBtn = document.getElementById('save-layout-btn');
        if (saveBtn) saveBtn.addEventListener('click', () => saveLayout());

        const searchInput = document.getElementById('search-input');
        const searchClear = document.getElementById('search-clear-btn');
        if (searchInput) {
            const sync = () => {
                const chip = searchInput.closest('.chip');
                if (chip) chip.classList.toggle('has-value', !!searchInput.value.trim());
            };
            searchInput.addEventListener('input', sync);
            sync();
        }
        if (searchClear) searchClear.addEventListener('click', (e) => {
            e.preventDefault(); e.stopPropagation();
            clearMoleculeSearchOnly();
        });

        const pathStart = document.getElementById('path-start-input');
        const pathEnd = document.getElementById('path-end-input');
        const pathClear = document.getElementById('path-clear-btn');
        const syncPath = () => {
            const chip = (pathStart && pathStart.closest('.chip')) || (pathEnd && pathEnd.closest('.chip'));
            const has = ((pathStart && pathStart.value.trim()) || (pathEnd && pathEnd.value.trim()));
            if (chip) chip.classList.toggle('has-value', !!has);
        };
        if (pathStart) pathStart.addEventListener('input', syncPath);
        if (pathEnd) pathEnd.addEventListener('input', syncPath);
        syncPath();
        if (pathClear) pathClear.addEventListener('click', (e) => {
            e.preventDefault(); e.stopPropagation();
            clearPathSearchOnly();
        });

        applyFrozenState();
    });


    // ============================================================
    // Layout file persistence via backend (/api/layout)
    // - Save positions to layout_positions.json on the server
    // - Load them on startup and hydrate localStorage autosave cache
    // ============================================================
    async function saveLayoutToServer(positions) {
        try {
            await fetch('/api/layout', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ positions })
            });
        } catch (e) {
            // ignore: keep UI responsive even if server write fails
            console.warn('[layout] save to server failed:', e.message || e);
        }
    }

    async function preloadLayoutFromServer() {
        try {
            const res = await fetch('/api/layout', { method: 'GET' });
            if (!res.ok) return false;
            const positions = await res.json();
            if (!positions || typeof positions !== 'object') return false;

            // Put into autosave cache so existing restoreLayoutAuto() works unchanged
            const autoKey = STORAGE_KEY + '_autosave';
            localStorage.setItem(autoKey, JSON.stringify(positions));
            return true;
        } catch (e) {
            console.warn('[layout] preload from server failed:', e.message || e);
            return false;
        }
    }

    async function clearLayoutOnServer() {
        try {
            await fetch('/api/layout', { method: 'DELETE' });
        } catch (e) {
            console.warn('[layout] clear on server failed:', e.message || e);
        }
    }


    // ============================================
    // 1. ä¿å­˜å¸ƒå±€å‡½æ•°
    // ============================================
    function saveLayout() {
        if (!window.cyGraph) return;

        const positions = {};
        // éå†æ‰€æœ‰èŠ‚ç‚¹ï¼Œè®°å½• ID å’Œ (x, y) åæ ‡
        window.cyGraph.nodes().forEach(node => {
            positions[node.id()] = node.position();
        });

        // è½¬æˆ JSON å­—ç¬¦ä¸²å­˜å…¥ LocalStorage
        localStorage.setItem(STORAGE_KEY, JSON.stringify(positions));
        
        
        // åŒæ­¥ä¿å­˜åˆ°æœåŠ¡å™¨æ–‡ä»¶ layout_positions.json
        saveLayoutToServer(positions);
alert(`Saved positions for ${Object.keys(positions).length} nodes. Your layout will be kept on refresh.`);
    }

    // ============================================
    // 2. æ¸…é™¤å¸ƒå±€(é‡ç½®)å‡½æ•°
    // ============================================
    function clearLayoutCache() {
        localStorage.removeItem(STORAGE_KEY);
                localStorage.removeItem(STORAGE_KEY + '_autosave');
        clearLayoutOnServer();
alert('Layout cache cleared. Refreshing to recompute the default layout.');
        location.reload(); // è‡ªåŠ¨åˆ·æ–°é¡µé¢
    }




    let cy = null;

        // ============================================================
    // æœç´¢åŠŸèƒ½æ¨¡å—
    // ============================================================
    function initSearchListener() {
        const searchInput = document.getElementById('search-input');
        if(searchInput) {
            // ç›‘å¬è¾“å…¥äº‹ä»¶ (input ä»£è¡¨æ¯æ¬¡æ‰“å­—éƒ½è§¦å‘)
            searchInput.addEventListener('input', function(e) {
                const term = e.target.value.trim();
                performSearch(term);
            });
        }

        // è·¯å¾„æœç´¢ç›¸å…³
        const startInput = document.getElementById('path-start-input');
        const endInput = document.getElementById('path-end-input');
        const pathBtn = document.getElementById('path-find-btn');

        if (pathBtn && startInput && endInput) {
            const doPathSearch = () => {
                const startTerm = startInput.value.trim();
                const endTerm = endInput.value.trim();
                if (!startTerm || !endTerm) {
                    const ps = document.getElementById('path-status');
                    if (ps) ps.innerText = 'Please enter both start and end molecules.';
                    return;
                }
                findPathBetweenMetabolites(startTerm, endTerm);
            };

            pathBtn.addEventListener('click', doPathSearch);
            endInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    doPathSearch();
                }
            });
        }
    }


        // ===================================
    // æœç´¢é€»è¾‘æ›´æ–° (æ”¯æŒå³ä¾§æ æ˜¾ç¤º + ç‚¹å‡»å®šä½)
    // ===================================
function safeFocus(el) {
    if (!el) return;
    try {
        window.requestAnimationFrame(() => {
            el.focus({ preventScroll: true });
            if (typeof el.setSelectionRange === 'function') {
                const v = el.value || '';
                el.setSelectionRange(v.length, v.length);
            }
        });
    } catch (e) {
        try { el.focus(); } catch (_) {}
    }
}

function calcSimilarity(term, label) {

        if (!term || !label) return 0;
        const a = String(term).toLowerCase().trim();
        const b = String(label).toLowerCase().trim();
        if (!a || !b) return 0;
        if (a === b) return 1;

        // å­ä¸²åŠ åˆ†
        if (b.includes(a) || a.includes(b)) {
            // é•¿åº¦è¶Šæ¥è¿‘åˆ†æ•°è¶Šé«˜
            const lenDiff = Math.abs(a.length - b.length);
            const maxLen = Math.max(a.length, b.length) || 1;
            const closeness = 1 - lenDiff / maxLen;
            return 0.7 + 0.3 * closeness; // 0.7 ~ 1.0
        }

        // ç®€å•ç¼–è¾‘è·ç¦»ï¼Œç”¨äºæ¨¡ç³ŠåŒ¹é…
        const lenA = a.length;
        const lenB = b.length;
        const dp = Array(lenA + 1).fill(null).map(() => Array(lenB + 1).fill(0));
        for (let i = 0; i <= lenA; i++) dp[i][0] = i;
        for (let j = 0; j <= lenB; j++) dp[0][j] = j;
        for (let i = 1; i <= lenA; i++) {
            for (let j = 1; j <= lenB; j++) {
                const cost = a[i - 1] === b[j - 1] ? 0 : 1;
                dp[i][j] = Math.min(
                    dp[i - 1][j] + 1,
                    dp[i][j - 1] + 1,
                    dp[i - 1][j - 1] + cost
                );
            }
        }
        const dist = dp[lenA][lenB];
        const maxLen = Math.max(lenA, lenB) || 1;
        const sim = 1 - dist / maxLen; // 0 ~ 1
        return sim * 0.6; // é™æƒä¸€ç‚¹ï¼Œé¿å…å‹è¿‡å­ä¸²åŒ¹é…
    }

    function performSearch(term) {
        const cy = window.cyGraph;
        if (!cy) return;

        const statusSpan = document.getElementById('search-status');
        const sidebar = document.getElementById('search-sidebar');

        // 1. å¦‚æœæœç´¢æ¡†æ¸…ç©º
        if (!term) {
            // æ¸…é™¤æ‰€æœ‰æœç´¢é«˜äº®/å˜æš—
            if (cy) {
                cy.elements().removeClass('dimmed').removeClass('highlighted');
                cy.nodes('[type="reaction"]').removeClass('search-focus-reaction');
            }
            // æ¢å¤ Pathway ç­›é€‰çŠ¶æ€
            filterGraph();
            // é‡ç½® UI
            statusSpan.innerText = "";
            if (sidebar) sidebar.style.display = 'none'; // éšè—å³ä¾§æ 
            return;
        }

        // 2. æ‰§è¡Œæœç´¢ï¼ˆæŒ‰Similarityæ’åºï¼‰
        cy.batch(() => {
            cy.elements().removeClass('highlighted').addClass('dimmed');

            const matches = [];
            cy.nodes().forEach(node => {
                const label = node.data('label');
                if (!label) return;
                const score = calcSimilarity(term, label);
                if (score > 0) {
                    matches.push({ node, score });
                }
            });

            if (matches.length === 0) {
                statusSpan.innerText = "No matching node found.";
                sidebar.style.display = 'none';
                return;
            }

            // æŒ‰Similarityä»é«˜åˆ°ä½æ’åº
            matches.sort((a, b) => b.score - a.score);

            const orderedNodes = matches.map(m => m.node);
            const scores = matches.map(m => m.score);

            const matchedNodes = cy.collection(orderedNodes);

            // é«˜äº®
            matchedNodes.removeClass('dimmed').addClass('highlighted');
            matchedNodes.neighborhood().removeClass('dimmed').addClass('highlighted');

            // æ›´æ–°é¡¶éƒ¨æ–‡å­—
            statusSpan.innerText = `Found ${matchedNodes.length} results`;

            // 3. ã€æ ¸å¿ƒã€‘æ¸²æŸ“å³ä¾§ç»“æœåˆ—è¡¨ï¼ˆå¸¦Similarityï¼‰
            renderSearchResults(orderedNodes, scores);
        });
    }


    // ============================================================
    // æœç´¢è·³è½¬å¢å¼ºï¼šç‚¹å‡»â€œåˆ†å­ç»“æœâ€æ—¶ï¼Œè‡ªåŠ¨å®šä½åˆ°å¯¹åº”çš„ååº”èŠ‚ç‚¹ï¼Œ
    // å¹¶å±•å¼€è¯¥ååº”çš„å…¨éƒ¨ååº”ç‰©/äº§ç‰©ï¼ˆå« otherï¼‰ï¼ŒåŒæ—¶åšç‰¹æ®Šé«˜äº®æ˜¾ç¤º
    // ============================================================

    function getLinkedReactionsFromMolecule(node) {
        const cy = window.cyGraph;
        if (!cy || !node) return [];

        // 1) side-moleculeï¼šExcel è¡Œé‡Œç»™äº† parentRxnï¼Œæœ€å¯é 
        if (node.hasClass && node.hasClass('side-molecule')) {
            const pr = node.data('parentRxn');
            if (pr) {
                const rxn = cy.$id(pr);
                if (rxn && rxn.length) return [rxn];
            }
        }

        // 2) main-moleculeï¼šä»è¿è¾¹é‡Œæ‰¾ç›¸é‚» reaction èŠ‚ç‚¹
        const rxnSet = new Set();
        node.connectedEdges().forEach(e => {
            const s = e.source();
            const t = e.target();
            const other = (s.id() === node.id()) ? t : s;
            if (other && other.data && other.data('type') === 'reaction') {
                rxnSet.add(other);
            }
        });

        return Array.from(rxnSet);
    }

    function pickBestReactionForMolecule(node) {
        const cy = window.cyGraph;
        if (!cy) return null;

        const reactions = getLinkedReactionsFromMolecule(node);
        if (!reactions.length) return null;

        // ä¼˜å…ˆï¼šé€šè¿‡ main è¾¹ç›¸è¿çš„ååº”ï¼ˆæ›´åƒâ€œä¸»ååº”é“¾â€ï¼‰
        const mainLinked = [];
        node.connectedEdges().forEach(e => {
            const other = (e.source().id() === node.id()) ? e.target() : e.source();
            if (other && other.data('type') === 'reaction' && e.data('edgeType') === 'main') {
                mainLinked.push(other);
            }
        });
        if (mainLinked.length) {
            return mainLinked.sort((a, b) => a.id().localeCompare(b.id()))[0];
        }

        // æ¬¡ä¼˜ï¼šæŒ‰ id ç¨³å®šé€‰ä¸€ä¸ªï¼ˆé¿å…æ¯æ¬¡éšæœºï¼‰
        return reactions.sort((a, b) => a.id().localeCompare(b.id()))[0];
    }

    function focusOnReaction(rxnNode, opts = {}) {
        const cy = window.cyGraph;
        if (!cy || !rxnNode || !rxnNode.length) return;

        const rxnId = rxnNode.id();

        // 1) è®©è¯¥ååº”æˆä¸ºâ€œé€‰ä¸­ååº”â€ï¼Œè§¦å‘å‰¯å°åˆ†å­å±•å¼€
        window.selectedReactionIds = new Set([rxnId]);
        refreshSideVisibility();

        // 2) æ¸…æ‰æ—§çš„æœç´¢ç„¦ç‚¹æ ·å¼
        cy.nodes('[type="reaction"]').removeClass('search-focus-reaction');

        // 3) è¦èšç„¦çš„å…ƒç´ ï¼šååº”èŠ‚ç‚¹ + é‚»åŸŸï¼ˆä¸»å¹² + å‰¯å°åˆ†å­ï¼‰
        const focusEles = rxnNode.closedNeighborhood();

        // 4) è§†è§‰ï¼šå…¨å›¾å˜æš—ï¼Œfocus åŒºåŸŸé«˜äº®
        cy.elements().removeClass('highlighted').addClass('dimmed');
        focusEles.removeClass('dimmed').addClass('highlighted');

        // 5) ååº”èŠ‚ç‚¹ç‰¹æ®Šæ ·å¼
        rxnNode.addClass('search-focus-reaction');

        // 6) è§†è§’è·³è½¬ï¼šfit åˆ°æ•´å¥—ååº”ï¼ˆè€Œä¸æ˜¯åˆ†å­ç‚¹æœ¬èº«ï¼‰
        cy.animate({
            fit: { eles: focusEles, padding: 180 },
            duration: 520,
            easing: 'ease-out-cubic'
        });

        // 7)ï¼ˆå¯é€‰ï¼‰æŠŠå‘½ä¸­çš„åˆ†å­ä¹Ÿç‚¹äº®ä¸€ä¸‹
        if (opts.alsoSelectNode && opts.alsoSelectNode.length) {
            opts.alsoSelectNode.removeClass('dimmed').addClass('highlighted');
        }
    }


    // æ¸²æŸ“å³ä¾§åˆ—è¡¨çš„å‡½æ•°
    function renderSearchResults(nodes, scores) {
        const sidebar = document.getElementById('search-sidebar');
        const listContainer = document.getElementById('search-results-list');
        const countSpan = document.getElementById('result-count');

        // æ˜¾ç¤ºä¾§è¾¹æ 
        sidebar.style.display = 'flex';
        listContainer.innerHTML = ''; // æ¸…ç©ºæ—§ç»“æœ
        countSpan.innerText = nodes.length;

        nodes.forEach((node, idxScore) => {
            const data = node.data();
            const score = Array.isArray(scores) ? scores[idxScore] : undefined;

            // åˆ›å»ºå¡ç‰‡ DOM
            const item = document.createElement('div');
            item.className = 'result-item';

            // åˆ¤æ–­ç±»å‹æ ‡ç­¾é¢œè‰²
            let typeColor = '#95a5a6';
            let typeText = 'Unknown';
            if(node.hasClass('reaction')) { typeColor = '#55efc4'; typeText = 'Enzyme/Reaction'; }
            else if(node.hasClass('main-molecule')) { typeColor = '#2ecc71'; typeText = 'Main Substrate'; }
            else { typeColor = '#74b9ff'; typeText = 'Other Substrate'; }

            const scoreHtml = (typeof score === 'number')
                ? `<div class="result-score" style="font-size:11px; color:#888;">Similarity ${(score*100).toFixed(0)}%</div>`
                : '';

            item.innerHTML = `
                <div class="result-name">
                    ${data.label || data.id}
                    <span class="result-type-tag" style="background:${typeColor}">${typeText}</span>
                </div>
                <div class="result-pathway">ğŸ“‚ ${data.pathway || 'Uncategorized'}</div>
                ${scoreHtml}
            `;

            // ç‚¹å‡»äº‹ä»¶ï¼šç§»åŠ¨è§†è§’ï¼ˆå‡çº§ï¼šè·³åˆ°ååº”èŠ‚ç‚¹ï¼Œå¹¶å±•å¼€å…¨éƒ¨ååº”ç‰©/äº§ç‰©ï¼‰
            item.addEventListener('click', () => {
                const cy = window.cyGraph;
                if (!cy) return;

                // 1) ä¼˜å…ˆæŠŠâ€œåˆ†å­å‘½ä¸­â€æ˜ å°„åˆ°å¯¹åº”çš„ååº”èŠ‚ç‚¹
                let rxnNode = null;
                const nType = node.data('type');

                if (nType === 'reaction') {
                    rxnNode = node;
                } else if (nType === 'molecule') {
                    rxnNode = pickBestReactionForMolecule(node);
                }

                // 2) æœ‰ååº”èŠ‚ç‚¹å°±èšç„¦åˆ°ååº”ï¼Œå¹¶å±•å¼€å‰¯å°åˆ†å­ï¼›å¦åˆ™å›é€€åˆ°æ—§è¡Œä¸º
                if (rxnNode && rxnNode.length) {
                    focusOnReaction(rxnNode, { alsoSelectNode: node });
                } else {
                    cy.elements().removeClass('highlighted').addClass('dimmed');
                    node.removeClass('dimmed').addClass('highlighted');
                    node.neighborhood().removeClass('dimmed').addClass('highlighted');
                    cy.animate({
                        fit: { eles: node, padding: 150 },
                        duration: 500,
                        easing: 'ease-out-cubic'
                    });
                }

                // 3) UIåé¦ˆï¼šç»™å½“å‰ç‚¹å‡»çš„åˆ—è¡¨é¡¹åŠ ä¸ªè¾¹æ¡†æ ‡è®°
                document.querySelectorAll('.result-item').forEach(d => d.style.borderColor = '#eee');
                item.style.borderColor = '#2196F3';
            
                safeFocus(document.getElementById('search-input'));
});

            listContainer.appendChild(item);
        });
    }

    // å…³é—­å³ä¾§æ 
    function closeSearchPanel() {
        const cy = window.cyGraph;
        const input = document.getElementById('search-input');
        const statusSpan = document.getElementById('search-status');
        const sidebar = document.getElementById('search-sidebar');

        // æ¸…ç©ºæœç´¢æ¡†ä¸çŠ¶æ€æ–‡å­—
        if (input) input.value = '';
        if (statusSpan) statusSpan.innerText = '';
        if (sidebar) sidebar.style.display = 'none';

        // æ¸…é™¤æœç´¢äº§ç”Ÿçš„é«˜äº® / å˜æš—
        if (cy) {
            cy.elements().removeClass('dimmed').removeClass('highlighted');
                cy.nodes('[type="reaction"]').removeClass('search-focus-reaction');
        }

        // æ¸…é™¤è·¯å¾„é«˜äº®
        if (typeof clearPathHighlight === 'function') {
            clearPathHighlight();
        }

        // æ¢å¤å½“å‰çš„ Pathway å¯è§æ€§ä¸å‰¯å°åˆ†å­/è·¨è†œæ˜¾éš
        filterGraph();
        safeFocus(document.getElementById('search-input'));
    }

    // æ¸…é™¤è·¯å¾„é«˜äº®
    function clearPathHighlight() {
        const cy = window.cyGraph;
        if (!cy) return;
        cy.elements('.path-node').removeClass('path-node');
        cy.elements('.path-edge').removeClass('path-edge');
        const ps = document.getElementById('path-status');
        if (ps) ps.innerText = '';
    }


    // Clear molecule search only (equivalent to emptying the molecule search box)
    function clearMoleculeSearchOnly() {
        closeSearchPanel();
        const input = document.getElementById('search-input');
        const chip = input ? input.closest('.chip') : null;
        if (chip) chip.classList.remove('has-value');
        safeFocus(document.getElementById('search-input'));
    }

    // Clear path search only (equivalent to emptying start/end and removing path highlights)
    function clearPathSearchOnly() {
        const cy = window.cyGraph;
        const startInput = document.getElementById('path-start-input');
        const endInput = document.getElementById('path-end-input');
        const status = document.getElementById('path-status');
        const sidebar = document.getElementById('search-sidebar');
        const listContainer = document.getElementById('search-results-list');
        const countSpan = document.getElementById('result-count');

        if (startInput) startInput.value = '';
        if (endInput) endInput.value = '';
        if (status) status.innerText = '';

        clearPathHighlight();

        // remove any residual focus styling
        if (cy) {
            cy.elements().removeClass('path-node').removeClass('path-edge');
        }

        // clear the right panel list
        if (listContainer) listContainer.innerHTML = '';
        if (countSpan) countSpan.innerText = 0;
        if (sidebar) sidebar.style.display = 'none';

        // restore visibility according to current pathway filter and side rules
        filterGraph();
        safeFocus(document.getElementById('path-start-input'));

        const chip = (startInput && startInput.closest('.chip')) || (endInput && endInput.closest('.chip'));
        if (chip) chip.classList.remove('has-value');
    }

    // Close the right panel and exit any active search/path mode
    function closeAllPanels() {
        clearMoleculeSearchOnly();
        clearPathSearchOnly();
    }


    // æ ¹æ®åç§°æŒ‘é€‰â€œæœ€ç›¸ä¼¼â€çš„åˆ†å­èŠ‚ç‚¹
    function pickBestMoleculeNodeByName(term) {
        const cy = window.cyGraph;
        if (!cy) return null;
        const lower = String(term || '').toLowerCase().trim();
        if (!lower) return null;

        let bestNode = null;
        let bestScore = 0;

        cy.nodes('[type = "molecule"]').forEach(node => {
            const label = node.data('label');
            if (!label) return;
            const score = calcSimilarity(lower, label);
            if (score > bestScore) {
                bestScore = score;
                bestNode = node;
            }
        });

        return bestNode;
    }

    // åœ¨ä»£è°¢ç½‘ç»œä¸­å¯»æ‰¾ä»Start moleculeåˆ°End moleculeçš„åˆæˆè·¯å¾„ï¼ˆæœ€çŸ­æ­¥æ•°ï¼‰
    
    
function findPathBetweenMetabolites(startName, endName) {
    const cy = window.cyGraph;
    if (!cy) return;

    const status = document.getElementById('path-status');
    clearPathHighlight();

    // === Tunables (no UI yet, but easy to expose later) ===
    const K_PATHS = 8;          // how many candidate paths to return
    const MAX_RXN_STEPS = 24;   // guardrail against explosion

    // Candidates: robust for compartments / similar names
    const getCandidates = (term, topN = 6, minScore = 0.62) => {
        const lower = String(term || '').toLowerCase().trim();
        if (!lower) return [];
        const scored = [];
        cy.nodes('[type="molecule"]').forEach(n => {
            const label = n.data('label');
            if (!label) return;
            const s = calcSimilarity(lower, label);
            if (s > 0) scored.push({ n, s });
        });
        scored.sort((a, b) => b.s - a.s);
        const picked = scored.filter(x => x.s >= minScore).slice(0, topN).map(x => x.n);
        if (picked.length) return picked;
        return scored.slice(0, 1).map(x => x.n);
    };

    const startNodes = getCandidates(startName);
    const endNodes = getCandidates(endName);

    if (!startNodes.length || !endNodes.length) {
        if (status) status.innerText = 'Could not find a matching start or end molecule.';
        renderPathResults([]);
        return;
    }

    const startLower = String(startName || '').toLowerCase().trim();
    const endLower = String(endName || '').toLowerCase().trim();

    // Helpers: visible-only by default (match current filtered view)
    const isVisible = (ele) => {
        try { return ele && ele.visible && ele.visible(); } catch (_) { return true; }
    };

    // Build neighbors on the fly:
    // 1) Transport edges: molecule <-> molecule (does not count as reaction step)
    // 2) Reaction flow: molecule --(in)--> reaction --(out)--> molecule (counts as one reaction step)
    const getTransportNeighbors = (molNode) => {
        const out = [];
        molNode.connectedEdges('edge[edgeType="transport"]').forEach(e => {
            if (!isVisible(e)) return;
            const other = (e.source().id() === molNode.id()) ? e.target() : e.source();
            if (other && other.data('type') === 'molecule' && isVisible(other)) {
                out.push({ to: other, kind: 'transport', rxn: null });
            }
        });
        return out;
    };

    const getReactionNeighbors = (molNode, includeSide) => {
        const out = [];
        const inSel = includeSide ? 'edge[type="in"]' : 'edge[type="in"][edgeType="main"]';
        const outSel = includeSide ? 'edge[type="out"]' : 'edge[type="out"][edgeType="main"]';

        // Molecule -> reactions (consumed as reactant)
        const rxnEdges = molNode.outgoers(inSel).filter(e => isVisible(e));
        rxnEdges.forEach(e => {
            const rxn = e.target();
            if (!rxn || rxn.data('type') !== 'reaction' || !isVisible(rxn)) return;

            // Reaction -> product molecules
            const prodEdges = rxn.outgoers(outSel).filter(ee => isVisible(ee));
            prodEdges.forEach(ee => {
                const prod = ee.target();
                if (!prod || prod.data('type') !== 'molecule') return;
                if (!isVisible(prod)) return;
                out.push({ to: prod, kind: 'rxn', rxn: rxn });
            });
        });

        return out;
    };

    // Min-heap on a composite key: (reactionSteps, totalNodes)
    class MinHeap {
        constructor() { this.a = []; }
        push(x) { this.a.push(x); this._up(this.a.length - 1); }
        pop() {
            if (!this.a.length) return null;
            const top = this.a[0];
            const last = this.a.pop();
            if (this.a.length) { this.a[0] = last; this._down(0); }
            return top;
        }
        _better(i, j) { return this.a[i].key < this.a[j].key; }
        _up(i) {
            while (i > 0) {
                const p = (i - 1) >> 1;
                if (this._better(p, i)) break;
                [this.a[p], this.a[i]] = [this.a[i], this.a[p]];
                i = p;
            }
        }
        _down(i) {
            const n = this.a.length;
            while (true) {
                let l = i * 2 + 1, r = l + 1, m = i;
                if (l < n && this._better(l, m)) m = l;
                if (r < n && this._better(r, m)) m = r;
                if (m === i) break;
                [this.a[m], this.a[i]] = [this.a[i], this.a[m]];
                i = m;
            }
        }
        get size() { return this.a.length; }
    }

    // Uniform-cost search that enumerates K candidate paths, ordered by reactionSteps (then path length)
    const enumerateKPaths = ({
        includeSide,
        endSet,
        cycleStartId = null,
        startSeeds = null,
        k = K_PATHS,
        maxSteps = MAX_RXN_STEPS
    }) => {
        const heap = new MinHeap();
        const results = [];
        const seenComplete = new Set();

        const pushState = (st) => {
            const keyBase = 1000000; // reactionSteps dominates
            st.key = st.steps * keyBase + st.nodes.length;
            heap.push(st);
        };

        // seed sources (multi-start)
        const seeds = (startSeeds && Array.isArray(startSeeds) && startSeeds.length) ? startSeeds : startNodes;
        seeds.forEach(s => {
            if (!isVisible(s)) return;
            pushState({
                steps: 0,
                lastMolId: s.id(),
                nodes: [s],
                visitedMol: new Set([s.id()]),
                usedRxn: new Set()
            });
        });

        while (heap.size && results.length < k) {
            const cur = heap.pop();
            if (!cur) break;
            if (cur.steps > maxSteps) continue;

            const atEnd = cycleStartId
                ? (cur.lastMolId === cycleStartId && cur.steps >= 1)
                : endSet.has(cur.lastMolId);

            if (atEnd) {
                const sig = cur.nodes.map(n => n.id()).join('>');
                if (!seenComplete.has(sig)) {
                    seenComplete.add(sig);
                    results.push({
                        nodes: cur.nodes,
                        reactionSteps: cur.steps,
                        totalNodes: cur.nodes.length
                    });
                }
                // don't early-break: we want K candidates
            }

            const curNode = cy.$id(cur.lastMolId);
            if (!curNode || !curNode.length) continue;

            // Expand transport neighbors (no extra reaction step)
            for (const nb of getTransportNeighbors(curNode)) {
                const toId = nb.to.id();
                if (!isVisible(nb.to)) continue;
                if (cur.visitedMol.has(toId)) {
                    // allow only closing the cycle back to start
                    if (!(cycleStartId && toId === cycleStartId && cur.steps >= 1)) continue;
                }
                const nxtVisited = new Set(cur.visitedMol);
                nxtVisited.add(toId);
                pushState({
                    steps: cur.steps,
                    lastMolId: toId,
                    nodes: cur.nodes.concat([nb.to]),
                    visitedMol: nxtVisited,
                    usedRxn: new Set(cur.usedRxn)
                });
            }

            // Expand reaction neighbors (adds 1 reaction step)
            for (const nb of getReactionNeighbors(curNode, includeSide)) {
                const rxn = nb.rxn;
                if (!rxn) continue;
                const rxnId = rxn.id();
                if (cur.usedRxn.has(rxnId)) continue; // avoid looping on the same reaction

                const toId = nb.to.id();
                if (!isVisible(nb.to)) continue;
                if (cur.visitedMol.has(toId)) {
                    if (!(cycleStartId && toId === cycleStartId && cur.steps >= 1)) continue;
                }

                const nxtVisited = new Set(cur.visitedMol);
                nxtVisited.add(toId);
                const nxtRxn = new Set(cur.usedRxn);
                nxtRxn.add(rxnId);

                pushState({
                    steps: cur.steps + 1,
                    lastMolId: toId,
                    nodes: cur.nodes.concat([rxn, nb.to]),
                    visitedMol: nxtVisited,
                    usedRxn: nxtRxn
                });
            }
        }

        // Ensure stable ordering
        results.sort((a, b) => (a.reactionSteps - b.reactionSteps) || (a.totalNodes - b.totalNodes));
        return results;
    };

    // Determine whether we're in "cycle mode" (user wants start -> ... -> start)
    // We trigger cycle mode only when the user literally typed the same term, to avoid surprising matches.
    const isCycleRequest = (startLower && endLower && startLower === endLower);

    const endSet = new Set(endNodes.map(n => n.id()));
    const overlap = startNodes.find(n => endSet.has(n.id()));

    let pathsInfo = [];

    if (isCycleRequest) {
        // Choose the best-resolved start node (first candidate), then enumerate cycles returning to itself.
        const cycleStart = startNodes.find(n => isVisible(n)) || startNodes[0];
        if (!cycleStart) {
            if (status) status.innerText = 'Could not resolve a visible start molecule for cycle search.';
            renderPathResults([]);
            return;
        }

        if (status) status.innerText = `Searching cycles that start and end at â€œ${cycleStart.data('label')}â€ ...`;

        // main-only first
        pathsInfo = enumerateKPaths({ includeSide: false, endSet: new Set([cycleStart.id()]), cycleStartId: cycleStart.id(), startSeeds: [cycleStart] });
        if (pathsInfo.length < K_PATHS) {
            const more = enumerateKPaths({ includeSide: true, endSet: new Set([cycleStart.id()]), cycleStartId: cycleStart.id(), startSeeds: [cycleStart] });
            const sig = new Set(pathsInfo.map(p => p.nodes.map(n => n.id()).join('>')));
            more.forEach(p => {
                const s = p.nodes.map(n => n.id()).join('>');
                if (!sig.has(s)) { sig.add(s); pathsInfo.push(p); }
            });
            pathsInfo.sort((a, b) => (a.reactionSteps - b.reactionSteps) || (a.totalNodes - b.totalNodes));
            pathsInfo = pathsInfo.slice(0, K_PATHS);
        }
    } else {
        // Normal A -> B path search (multiple candidates, K shortest)
        if (overlap) {
            // If candidates collapse to the same node but the user didn't ask for a cycle, be explicit.
            overlap.addClass('path-node');
            if (status) status.innerText = 'Start and end resolved to the same molecule. If you want a loop, enter the same name in both boxes.';
            renderPathResults([]);
            return;
        }

        // main-only first
        pathsInfo = enumerateKPaths({ includeSide: false, endSet });
        if (pathsInfo.length < K_PATHS) {
            const more = enumerateKPaths({ includeSide: true, endSet });
            const sig = new Set(pathsInfo.map(p => p.nodes.map(n => n.id()).join('>')));
            more.forEach(p => {
                const s = p.nodes.map(n => n.id()).join('>');
                if (!sig.has(s)) { sig.add(s); pathsInfo.push(p); }
            });
            pathsInfo.sort((a, b) => (a.reactionSteps - b.reactionSteps) || (a.totalNodes - b.totalNodes));
            pathsInfo = pathsInfo.slice(0, K_PATHS);
        }
    }

    if (!pathsInfo || !pathsInfo.length) {
        if (status) {
            status.innerText = isCycleRequest
                ? 'No directed cycle found that returns to the start molecule in the current network.'
                : 'No directed path found between the start and end in the current network.';
        }
        renderPathResults([]);
        return;
    }

    applyPathHighlight(pathsInfo[0].nodes);
    renderPathResults(pathsInfo);

    if (status) {
        const tag = isCycleRequest ? 'cycle(s)' : 'path(s)';
        status.innerText = `Found ${pathsInfo.length} ${tag}. Shortest has ${pathsInfo[0].reactionSteps} reaction step(s).`;
    }

    safeFocus(document.getElementById('path-end-input'));
}

// é«˜äº®å¹¶èšç„¦ä¸€æ¡ç»™å®šè·¯å¾„
    function applyPathHighlight(pathNodes) {
        const cy = window.cyGraph;
        if (!cy || !pathNodes || !pathNodes.length) return;

        clearPathHighlight();

        const pathNodesCol = cy.collection(pathNodes);
        pathNodesCol.addClass('path-node');

        const pathEdges = [];
        for (let i = 0; i < pathNodes.length - 1; i++) {
            const a = pathNodes[i];
            const b = pathNodes[i + 1];
            const edgesAB = a.edgesTo(b);
            edgesAB.forEach(e => pathEdges.push(e));
        }
        const pathEdgesCol = cy.collection(pathEdges);
        pathEdgesCol.addClass('path-edge');

        // When showing a path, reveal side molecules for the involved reactions
        try {
            const rxnIds = new Set();
            cy.collection(pathNodes)
                .filter('node[type="reaction"]')
                .forEach(n => rxnIds.add(n.id()));
            window.selectedReactionIds = rxnIds;
            if (typeof refreshSideVisibility === 'function') {
                refreshSideVisibility();
            }
        } catch (e) {
            // non-fatal
        }

        cy.animate({
            fit: {
                eles: pathNodesCol.union(pathEdgesCol),
                padding: 80
            },
            duration: 500,
            easing: 'ease-out-cubic'
        });
    }

    // åœ¨å³ä¾§åˆ—è¡¨ä¸­å±•ç¤ºå¤šæ¡è·¯å¾„ï¼ˆä»çŸ­åˆ°é•¿ï¼‰
    function renderPathResults(pathsInfo) {
        const sidebar = document.getElementById('search-sidebar');
        const listContainer = document.getElementById('search-results-list');
        const countSpan = document.getElementById('result-count');

        if (!sidebar || !listContainer || !countSpan) return;

        // å¦‚æœæ²¡æœ‰è·¯å¾„ï¼Œä¸”å½“å‰ä¹Ÿä¸æ˜¯æœç´¢æ¨¡å¼ï¼Œå°±ç®€å•æ¸…ç©º
        if (!pathsInfo || pathsInfo.length === 0) {
            listContainer.innerHTML = '';
            countSpan.innerText = 0;
            // ä¸å¼ºåˆ¶éšè—ä¾§è¾¹æ ï¼Œäº¤ç»™ closeSearchPanel æˆ–æœç´¢é€»è¾‘æ§åˆ¶
            return;
        }

        sidebar.style.display = 'flex';
        listContainer.innerHTML = '';

        countSpan.innerText = pathsInfo.length;

        pathsInfo.forEach((info, idx) => {
            const item = document.createElement('div');
            item.className = 'result-item';

            const stepText = `${info.reactionSteps} reaction step(s)`;
            const nodeLabels = info.nodes
                .map(n => n.data && (n.data('label') || n.id()))
                .filter(Boolean);

            // åªå±•ç¤ºå‰è‹¥å¹²ä¸ªèŠ‚ç‚¹ï¼Œé¿å…å¤ªé•¿
            const preview = nodeLabels.slice(0, 6).join(' â†’ ') +
                (nodeLabels.length > 6 ? ' â†’ ...' : '');

            item.innerHTML = `
                <div class="result-name">
                    Path ${idx + 1}
                    <span class="result-type-tag" style="background:#e67e22;">${stepText}</span>
                </div>
                <div class="result-pathway" style="font-size:11px; color:#555; margin-top:2px;">
                    ${preview}
                </div>
            `;

            item.addEventListener('click', () => {
                applyPathHighlight(info.nodes);
                const ps = document.getElementById('path-status');
                if (ps) {
                    ps.innerText = `Showing Path ${idx + 1} (${info.reactionSteps} reaction steps)`;
                }
                document.querySelectorAll('.result-item').forEach(d => d.style.borderColor = '#eee');
                item.style.borderColor = '#e67e22';
            
                safeFocus(document.getElementById('path-end-input'));
});

            listContainer.appendChild(item);
        });
    }


    // é¡µé¢åŠ è½½å®Œæˆåæ‰§è¡Œ
    window.onload = async function() {
        try {
            if (typeof cytoscapeDagre !== 'undefined') {
                cytoscape.use(cytoscapeDagre);
            }
        } catch (e) { console.warn("Layout plugin already registered"); }

        await loadAndMergeSheets();
    };

    async function loadAndMergeSheets() {
        document.getElementById('loading').style.display = 'flex';
        updateStatus(`Loading sheets: ${TARGET_SHEETS.join(', ')}...`);

        try {
            let combinedData = [];
            const requests = TARGET_SHEETS.map(name =>
                fetch(`/api/data/${encodeURIComponent(name)}`)
                    .then(res => {
                        if(!res.ok) throw new Error(`Sheet [${name}] does not exist or failed to read`);
                        return res.json();
                    })
                    .then(sheetData => {
                        // ç»™æ¯ä¸€è¡ŒåŠ ä¸Šæ¥æº sheet æ ‡ç­¾ï¼Œä¾¿äºåˆ†ç»„ä¸é…è‰²
                        sheetData.forEach(row => row.__sheet = name);
                        return sheetData;
                    })
            );

            const results = await Promise.all(requests);
            results.forEach(sheetData => {
                combinedData = combinedData.concat(sheetData);
            });


            console.log(`Loaded ${combinedData.length} rows in total`);
                        // é¢„åŠ è½½ä¸Šä¸€æ¬¡ä¿å­˜çš„å¸ƒå±€åæ ‡ï¼ˆæœåŠ¡å™¨æ–‡ä»¶ï¼‰
            await preloadLayoutFromServer();

            processDataAndDraw(combinedData);

        } catch (err) {
            console.error(err);
            showError(`Load failed: ${err.message}`);
        } finally {
            document.getElementById('loading').style.display = 'none';
        }
    }

        // ============================================================
    // 1. æ•°æ®å¤„ç† (Process Data) - ä¿®æ”¹ç‰ˆï¼šå‰¯äº§ç‰©ä¸åˆå¹¶
    // ============================================================
        // ============================================================
    // 1. æ•°æ®å¤„ç† (Process Data) - å·²ä¿®æ”¹æ”¯æŒé…è‰²åŒºåˆ†
    // ============================================================
    function processDataAndDraw(data) {
        const elements = [];
        const pathwaySet = new Set();

        // --- å·¦ä¾§æ åˆ†ç»„ï¼šæŒ‰ sheet è®°å½• Pathway å‡ºç°é¡ºåºï¼ˆä¿æŒ Excel ä¸­çš„é¡ºåºï¼‰ ---
        const pathwaysBySheet = new Map();
        const pathwaySeenBySheet = new Map();
        TARGET_SHEETS.forEach(s => {
            pathwaysBySheet.set(s, []);
            pathwaySeenBySheet.set(s, new Set());
        });

        const addedMainNodes = new Set();

        // --- ä¸»å¹²åˆ†å­å…ƒä¿¡æ¯ï¼šç”¨äºå¤š-sheet å–è‰² & é€‰ä¸­ Pathway æ—¶ä¸´æ—¶æ”¹è‰² ---
        // Map<nodeId, { sheets:Set<string>, pathwaySheets: Map<pathway, Set<sheet>> }>
        const mainMoleculeMeta = new Map();
        window.mainMoleculeMeta = mainMoleculeMeta;

        // 1. ä¸»å¹²èŠ‚ç‚¹ (ä¸»è¦ååº”ç‰©/äº§ç‰©) -> é¢œè‰²ç”± sheet å†³å®šï¼ˆdata.colorï¼‰
                // 1. ä¸»å¹²èŠ‚ç‚¹ (ä¸»è¦ååº”ç‰©/äº§ç‰©) -> é¢œè‰²ç”± sheet å†³å®šï¼ˆdata.colorï¼‰
        // è¯´æ˜ï¼šåŒååˆ†å­åœ¨ä¸åŒç»†èƒå™¨(Place in Cell)ä¼šç”Ÿæˆä¸åŒèŠ‚ç‚¹ï¼Œç”¨äºé¿å…é‡åˆï¼Œå¹¶é¢å¤–ç”Ÿæˆâ€œè½¬è¿(transport)â€è¿æ¥
        const moleculeCompNodes = new Map(); // Map<baseName, Array<nodeId>>
        const addMainNode = (baseName, compKey, sheetName, pathwayName) => {
            if (!baseName) return;

            const nodeId = makeCompartmentNodeId(baseName, compKey);

            // metaMap æŒ‰â€œåˆ†å­åŸºåâ€èšåˆï¼šç”¨äºå¤š-sheet å–è‰²
            if (!mainMoleculeMeta.has(baseName)) {
                mainMoleculeMeta.set(baseName, { sheets: new Set(), pathwaySheets: new Map() });
            }
            const meta = mainMoleculeMeta.get(baseName);
            if (sheetName) meta.sheets.add(sheetName);

            if (pathwayName) {
                if (!meta.pathwaySheets.has(pathwayName)) meta.pathwaySheets.set(pathwayName, new Set());
                if (sheetName) meta.pathwaySheets.get(pathwayName).add(sheetName);
            }

            // è®°å½•â€œåŒååˆ†å­â€çš„ä¸åŒç»†èƒå™¨èŠ‚ç‚¹ï¼Œç”¨äºåç»­è½¬è¿è¿çº¿
            if (!moleculeCompNodes.has(baseName)) moleculeCompNodes.set(baseName, []);
            if (!moleculeCompNodes.get(baseName).includes(nodeId)) moleculeCompNodes.get(baseName).push(nodeId);

            if (!addedMainNodes.has(nodeId)) {
                elements.push({
                    data: {
                        id: nodeId,
                        label: baseName,          // å±•ç¤ºåä¿æŒä¸€è‡´
                        baseName: baseName,       // ç”¨äºå–è‰²/èšåˆ
                        compartment: compKey || '',
                        type: 'molecule',
                        color: '#2ecc71'          // color åç»­ç»Ÿä¸€å›å¡«
                    },
                    classes: 'main-molecule'
                });
                addedMainNodes.add(nodeId);
            }
        };


const addSideNode = (newId, labelName, extraClass, parentRxn, role, pathway, sheet) => {
            elements.push({
                data: {
                    id: newId,
                    label: labelName,
                    type: 'molecule',
                    parentRxn: parentRxn || '',
                    role: role || '',
                    pathway: pathway || '',
                    sheet: sheet || ''
                },
                // é»˜è®¤éšè—å‰¯å°åˆ†å­ï¼Œåªæœ‰é€‰ä¸­ååº”æˆ–ç‚¹å‡» pathway æŒ‰é’®æ‰æ˜¾ç¤º
                classes: `side-molecule ${extraClass} hidden-side`
            });
        };

        const parseMolecules = (str) => {
            if (!str) return [];
            return String(str).split(';').map(s => s.split(':')[0].trim()).filter(s => s);
        };
        // Place in Cell: ä½œä¸ºç»†èƒå™¨æ ‡ç­¾ï¼Œç”¨æ¥åŒºåˆ†åŒååˆ†å­åœ¨ä¸åŒç»†èƒå™¨ä¸­çš„å®ä¾‹
        const normalizeCompartment = (place) => {
            if (!place) return '';
            const raw = String(place).trim();
            if (!raw || raw === '0') return '';
            // å–ç¬¬ä¸€ä¸ªæ ‡ç­¾ï¼ˆè‹¥æœ‰å¤šä¸ªç”¨ ; æˆ– , åˆ†éš”ï¼‰
            const first = raw.split(/[;,]/)[0].trim();
            // ä¸º node id ç”Ÿæˆâ€œç›¸å¯¹å®‰å…¨â€ä¸”æ”¯æŒä¸­æ–‡çš„ keyï¼š
            // ä¿ç•™ä¸­æ–‡ + å­—æ¯æ•°å­—ï¼Œç”¨ä¸‹åˆ’çº¿æ›¿æ¢å…¶ä»–ç¬¦å·ï¼Œé¿å…å…¨éƒ¨å˜æˆä¸‹åˆ’çº¿å¯¼è‡´â€œçœ‹èµ·æ¥åƒä¹±ç â€
            return first
                .toLowerCase()
                .replace(/\s+/g, '_')
                .replace(/[^a-z0-9_\u4e00-\u9fa5]/g, '_');
        };

        const makeCompartmentNodeId = (baseName, compKey) => {
            if (!compKey) return baseName;
            return `${baseName}@@${compKey}`;
        };

        // ç”Ÿæˆâ€œç¨³å®šâ€çš„ååº”èŠ‚ç‚¹ IDï¼šå°½å¯èƒ½ä¾èµ–äºååº”çš„å†…å®¹ï¼Œè€Œä¸æ˜¯å…¨å±€è¡Œå·
        // è¿™æ ·åœ¨ Excel ä¸­æ’å…¥/åˆ é™¤å‰é¢çš„è¡Œæ—¶ï¼Œå·²æœ‰ååº”çš„ id ä¸ä¼šå…¨éƒ¨é‡æ’
        const makeReactionId = (row, index, mainSources, mainTargets, sheetName) => {
            const sheet = (sheetName || row.__sheet || 'sheet').toString().trim();
            const pathway = (row['Pathway'] || '').toString().trim();
            const enzyme = (row['Enzyme'] || '').toString().trim();
            const srcStr = Array.isArray(mainSources) ? mainSources.join('+') : '';
            const tgtStr = Array.isArray(mainTargets) ? mainTargets.join('+') : '';

            let rawKey = `${sheet}|${pathway}|${enzyme}|${srcStr}|${tgtStr}`;
            // å¦‚æœè¿™ä¸€è¡Œå‡ ä¹ä»€ä¹ˆä¿¡æ¯éƒ½æ²¡æœ‰ï¼Œå°±é€€å›åˆ° indexï¼Œé¿å…ç©º id
            if (!rawKey.replace(/[|]/g, '').trim()) {
                rawKey = `${sheet}|idx_${index}`;
            }

            const safe = rawKey
                .toLowerCase()
                .replace(/\s+/g, '_')
                .replace(/[^a-z0-9_\u4e00-\u9fa5|]/g, '_');

            return `rxn_${safe}`;
        };

        data.forEach((row, index) => {
            const mainSources = parseMolecules(row['Main Reactant']);
            const sideSources = parseMolecules(row['Other Reactant']); 
            const mainTargets = parseMolecules(row['Main Product']);
            const sideTargets = parseMolecules(row['Other Product']); 

            if (mainSources.length + sideSources.length > 0 && mainTargets.length + sideTargets.length > 0) {
                const pathway = row['Pathway'];
                const enzyme = row['Enzyme'];
                const sheetName = row.__sheet || 'Unknown';
                const compKey = normalizeCompartment(row['Place in Cell']);

                if (pathway) {
                    pathwaySet.add(pathway);

                    if (!pathwaysBySheet.has(sheetName)) {
                        pathwaysBySheet.set(sheetName, []);
                        pathwaySeenBySheet.set(sheetName, new Set());
                    }
                    const seen = pathwaySeenBySheet.get(sheetName);
                    if (!seen.has(pathway)) {
                        pathwaysBySheet.get(sheetName).push(pathway);
                        seen.add(pathway);
                    }
                }
const rxnId = makeReactionId(row, index, mainSources, mainTargets, sheetName);
                // ç®€å•çš„åˆ¤æ–­æ˜¾ç¤º Label
                const isZeroEnzyme = !enzyme || String(enzyme).trim() === '0' || String(enzyme).trim() === '';
                const labelText = isZeroEnzyme ? '' : enzyme;
                
                // ååº”èŠ‚ç‚¹
                elements.push({
                    data: { 
                        id: rxnId, 
                        label: labelText, 
                        type: 'reaction', // ç”¨äºè¯†åˆ«é…¶èŠ‚ç‚¹
                        pathway: pathway || 'Uncategorized'
                    },
                    classes: 'reaction' // ç»Ÿä¸€ååº”èŠ‚ç‚¹ç±»å
                });

                // --- å¤„ç†å…¥è¾¹ (Input) ---

                // Main Sources
                mainSources.forEach(sourceName => {
                    const srcId = makeCompartmentNodeId(sourceName, compKey);
                    addMainNode(sourceName, compKey, sheetName, pathway);
                    elements.push({
                        data: { 
                            source: srcId, target: rxnId, 
                            pathway: pathway, type: 'in', edgeType: 'main' // type='in'
                        },
                        classes: 'edge-main'
                    });
                });

                // Side Sources (å‰¯ååº”ç‰©) -> æµ…è“è‰²
                sideSources.forEach((sourceName, i) => {
                    const uniqueSideId = `${rxnId}_side_in_${sourceName}_${i}`;
                    // [ä¿®æ”¹] ä¼ å…¥ sub-reactant
                    addSideNode(uniqueSideId, sourceName, 'sub-reactant', rxnId, 'in', pathway, sheetName);

                    elements.push({
                        data: {
                            source: uniqueSideId, target: rxnId, 
                            pathway: pathway, type: 'in', edgeType: 'side' // type='in'
                        },
                        classes: 'edge-side hidden-side' });
                });

                // --- å¤„ç†å‡ºè¾¹ (Output) ---

                // Main Targets
                mainTargets.forEach(targetName => {
                    const tgtId = makeCompartmentNodeId(targetName, compKey);
                    addMainNode(targetName, compKey, sheetName, pathway);
                    elements.push({
                        data: { 
                            source: rxnId, target: tgtId, 
                            pathway: pathway, type: 'out', edgeType: 'main' // type='out'
                        },
                        classes: 'edge-main'
                    });
                });

                // Side Targets (å‰¯ç”Ÿæˆç‰©) -> æµ…ç´«è‰²
                sideTargets.forEach((targetName, i) => {
                    const uniqueSideId = `${rxnId}_side_out_${targetName}_${i}`;
                    // [ä¿®æ”¹] ä¼ å…¥ sub-product
                    addSideNode(uniqueSideId, targetName, 'sub-product', rxnId, 'out', pathway, sheetName);

                    elements.push({
                        data: { 
                            source: rxnId, target: uniqueSideId, 
                            pathway: pathway, type: 'out', edgeType: 'side' // type='out'
                        },
                        classes: 'edge-side hidden-side' });
                });
            }
        });

        // å›å¡«ä¸»å¹²åˆ†å­çš„é»˜è®¤é¢œè‰²ï¼ˆæŒ‰ sheet ä¼˜å…ˆçº§ï¼‰
        elements.forEach(el => {
            if (el && el.classes && String(el.classes).includes('main-molecule')) {
                const meta = mainMoleculeMeta.get(el.data.id);
                if (meta) {
                    el.data.color = pickSheetColor(meta.sheets);
                }
            }
        });

        generateCheckboxes(pathwaysBySheet);

        // --- æ–°å¢ï¼šåŒååˆ†å­åœ¨ä¸åŒç»†èƒå™¨ä¹‹é—´çš„â€œè½¬è¿â€è¿çº¿ ---
        // è§„åˆ™ï¼šè‹¥åŒä¸€ baseName åœ¨å¤šä¸ª compartment èŠ‚ç‚¹å‡ºç°ï¼Œåˆ™ä»ç¬¬ä¸€ä¸ªå‡ºç°çš„èŠ‚ç‚¹ä½œä¸º hubï¼Œè¿æ¥åˆ°å…¶ä»– compartment èŠ‚ç‚¹
        const safeKey = (s) => String(s).toLowerCase().replace(/[^a-z0-9_]/g, '_');
        moleculeCompNodes.forEach((nodeIds, baseName) => {
            const uniq = Array.from(new Set(nodeIds)).filter(Boolean);
            if (uniq.length <= 1) return;

            const hub = uniq[0];
            const baseSafe = safeKey(baseName);
            for (let i = 1; i < uniq.length; i++) {
                const other = uniq[i];
                const eid = `transport__${baseSafe}__${i}`;
                elements.push({
                    data: {
                        id: eid,
                        source: hub,
                        target: other,
                        edgeType: 'transport',
                        baseName: baseName
                    },
                    classes: 'edge-transport'
                });
            }
        });

        updateStatus('');
        drawCytoscape(elements);
    }

    // ============================================================
    // 2. Cytoscape ç»˜å›¾ä¸å¸ƒå±€ (Draw & Layout)
    // ============================================================
    function drawCytoscape(allElements) {
        const container = document.getElementById('cy');
        const progressBar = document.getElementById('progress-bar');
        const progressText = document.getElementById('progress-text');
        const loadingMask = document.getElementById('loading-mask');

        // 1. åˆå§‹åŒ–ç©ºå›¾è¡¨
        window.cyGraph = cytoscape({
            container: container,
            // é™åˆ¶æ»šè½®ç¼©æ”¾é€Ÿåº¦ï¼Œé˜²æ­¢ä¸€æ»šè½®å›¾ä¹Ÿæ²¡äº†
            wheelSensitivity: 0.2, 
                    style: [
            // -----------------------------------------------------
            // 1. åŸºç¡€é»˜è®¤å€¼
            // -----------------------------------------------------
            {
                selector: 'node',
                style: {
                    'label': 'data(label)',
                    'text-valign': 'center', 'text-halign': 'center',
                    'font-size': '12px', 'color': '#fff',
                    'text-wrap': 'wrap',
                    'border-width': 0, // é»˜è®¤æ— è¾¹æ¡†
                    'shape': 'round-rectangle',
                    'width': 'label', 'height': 'label', 'padding': '8px'
                }
            },
            {
                selector: 'edge',
                style: {
                    'width': 2,
                    'curve-style': 'bezier'
                }
            },

            // -----------------------------------------------------
            // 2. èŠ‚ç‚¹é…è‰² (æ ¹æ®æ‚¨è¦æ±‚çš„é¢œè‰²)
            // -----------------------------------------------------
            
            // ã€ä¸»è¦ååº”ç‰©/äº§ç‰©ã€‘ï¼šç»¿è‰²èƒŒæ™¯ï¼Œæ— è¾¹æ¡†
            {
                selector: '.main-molecule',
                style: {
                    'background-color': 'data(color)', // ç”± sheet å†³å®š
                    'font-weight': 'bold',
                    'color': '#fff'
                }
            },

            // ã€å‰¯ååº”ç‰©ã€‘ï¼šæµ…è“è‰²èƒŒæ™¯ï¼Œæ— è¾¹æ¡†
            {
                selector: '.sub-reactant',
                style: {
                    'background-color': '#74b9ff', // æµ…è“
                    'font-size': '10px',
                    'padding': '5px'
                }
            },

            // ã€å‰¯ç”Ÿæˆç‰©ã€‘ï¼šæµ…ç´«è‰²èƒŒæ™¯ï¼Œæ— è¾¹æ¡†
            {
                selector: '.sub-product',
                style: {
                    'background-color': '#a29bfe', // æµ…ç´«
                    'font-size': '10px',
                    'padding': '5px'
                }
            },
            // ã€éšè—çš„å‰¯å°åˆ†å­/å‰¯è¿çº¿ã€‘ï¼šé»˜è®¤ä¸æ˜¾ç¤º
            {
                selector: '.hidden-side',
                style: {
                    'display': 'none'
                }
            },


            // ã€éšè—çš„è·¨è†œè¿è¾“è¾¹ã€‘ï¼šé»˜è®¤ä¸æ˜¾ç¤ºï¼Œç”±é€»è¾‘æ§åˆ¶æ˜¾ç¤º
            {
                selector: '.hidden-transport',
                style: {
                    'display': 'none'
                }
            },


            // ã€Enzyme/ReactionèŠ‚ç‚¹ã€‘ï¼šæ— èƒŒæ™¯ï¼Œæµ…ç»¿è‰²è¾¹æ¡†
            {
                // ä½¿ç”¨ type é€‰æ‹©å™¨æˆ–è€… class é€‰æ‹©å™¨
                selector: 'node[type="reaction"]',
                style: {
                    'background-color': '#e5e5e5', // æµ…ç°è‰²èƒŒæ™¯
                    'background-opacity': 1,
                    'border-width': 0,
                    'color': '#000',               // é»‘è‰²å­—ä½“
                    'font-weight': 'normal',         // åŠ ç²—
                    'shape': 'ellipse',
                    'font-size': '11px',
                    'width': 'label', 'height': 'label', 'padding': '6px'
                }
            },

            // ã€æœç´¢èšç„¦çš„ååº”èŠ‚ç‚¹ã€‘ï¼šçº¢è‰²æè¾¹ + æ›´é†’ç›®
            {
                selector: '.search-focus-reaction',
                style: {
                    'border-width': 4,
                    'border-color': '#d63031',
                    'font-weight': 'bold',
                    'z-index': 1000,
                    'shadow-blur': 8,
                    'shadow-opacity': 0.35,
                    'shadow-color': '#d63031'
                }
            },


            // -----------------------------------------------------
            // 3. è¿çº¿é…è‰²ä¸ç®­å¤´ (é€»è¾‘æ ¸å¿ƒ)
            // -----------------------------------------------------

            // ã€æŒ‡å‘ååº”èŠ‚ç‚¹çš„è¾¹ (In)ã€‘ï¼šæµ…ç»¿è‰²ï¼Œæ— ç®­å¤´
            // åŒ¹é… data.type === 'in'
            {
                selector: 'edge[type="in"]',
                style: {
                    'line-color': '#C0C0C0',       // æµ…ç»¿è‰²
                    'target-arrow-shape': 'none',  // æ— ç®­å¤´
                    'width': 4           // çº¿æ›´ç²—ï¼Œç®­å¤´ä¹Ÿä¼šæ›´â€œæœ‰å­˜åœ¨æ„Ÿâ€
                }
            },

            // ã€ç¦»å¼€ååº”èŠ‚ç‚¹çš„è¾¹ (Out)ã€‘ï¼šç»¿è‰²ï¼Œæœ‰ç®­å¤´
            // åŒ¹é… data.type === 'out'
            {
                selector: 'edge[type="out"]',
                style: {
                    'line-color': '#CDCDCD',       // ç»¿è‰²
                    'target-arrow-shape': 'triangle', // ä¸‰è§’å½¢ç®­å¤´
                    'target-arrow-color': '#CDCDCD',
                    'arrow-scale': 1.6,   // è°ƒå¤§ç®­å¤´ï¼ˆé»˜è®¤å¤§æ¦‚æ˜¯ 1ï¼‰
                    'width': 4            // çº¿æ›´ç²—ï¼Œç®­å¤´ä¹Ÿä¼šæ›´â€œæœ‰å­˜åœ¨æ„Ÿâ€
                }
            },

            

            // ã€ç»†èƒå™¨è½¬è¿è¾¹ (Transport)ã€‘ï¼šç°è‰²è™šçº¿ï¼Œæ— ç®­å¤´ï¼ˆåŒååˆ†å­ä¸åŒç»†èƒå™¨ä¹‹é—´ï¼‰
            {
                selector: '.edge-transport',
                style: {
                    'line-color': '#CDCDCD',
                    'line-style': 'dashed',
                    'width': 1,
                    'target-arrow-shape': 'none',
                    'opacity': 1.0
                }
            },
// -----------------------------------------------------
            // 4. äº¤äº’é«˜äº®æ ·å¼ (ä¿æŒåŸæœ‰çš„åŠŸèƒ½)
            // -----------------------------------------------------
            {
                selector: ':selected',
                style: {
                    'background-color': '#e17055',
                    'line-color': '#e17055',
                    'target-arrow-color': '#e17055'
                }
            },
            {
                selector: '.dimmed',
                style: { 'opacity': 0.1, 'z-index': 0 }
            },
            {
                selector: '.highlighted',
                style: {
                    'opacity': 1,
                    // 'border-width': 3,
                    // 'border-color': '#d63031', // æœç´¢é«˜äº®çº¢æ¡†
                    'z-index': 999
                }
            },
            {
                selector: '.path-node',
                style: {
                    'border-width': 3,
                    'border-color': '#e67e22',
                    'z-index': 1000
                }
            },
            {
                selector: '.path-edge',
                style: {
                    'line-color': '#e67e22',
                    'width': 4,
                    'opacity': 0.9,
                    'z-index': 1000
                }
            }
        ],

            // åˆå§‹æ”¾å®½é™åˆ¶ï¼Œé˜²æ­¢å¸ƒå±€è®¡ç®—æ—¶è¢«å¡ä½
            minZoom: 1e-50,
            maxZoom: 1e50,
            zoomingEnabled: true,
            panningEnabled: true,
            layout: { name: 'preset' }, // åˆå§‹ä¸è®¡ç®—å¸ƒå±€
            elements: [] 
        });

                applyFrozenState();

// ==========================================
        // å…³é”®ä¿®å¤ï¼šåˆ†ç¦» èŠ‚ç‚¹(Node) å’Œ è¿çº¿(Edge)
        // ==========================================
        const allNodes = [];
        const edgesByPathway = {};
        const pathwayNames = [];

        allElements.forEach(ele => {
            // åˆ¤æ–­æ˜¯å¦ä¸ºèŠ‚ç‚¹ï¼ˆgroupä¸å†™é»˜è®¤æ˜¯nodesï¼Œæˆ–è€…åˆ¤æ–­ data.source æ˜¯å¦å­˜åœ¨ï¼‰
            // Cytoscape JSON ä¸­ï¼Œè¿çº¿é€šå¸¸æœ‰ data.source å’Œ data.target
            if (ele.group === 'nodes' || (!ele.data.source && !ele.data.target)) {
                allNodes.push(ele);
            } else {
                // è¿™æ˜¯ä¸€ä¸ªè¿çº¿ (Edge)
                const p = ele.data.pathway || 'Other';
                if (!edgesByPathway[p]) {
                    edgesByPathway[p] = [];
                    pathwayNames.push(p); // è®°å½•é€šè·¯å
                }
                edgesByPathway[p].push(ele);
            }
        });

        // 2. ç¬¬ä¸€æ­¥ï¼šå®‰å…¨æ·»åŠ æ‰€æœ‰èŠ‚ç‚¹ (ä¸ä¼šæŠ¥é”™ï¼Œå› ä¸ºèŠ‚ç‚¹ä¸ä¾èµ–åˆ«äºº)
        // ä¸ºäº†é˜²æ­¢ä¸€å¼€å§‹ä¹Ÿæ˜¯ä¹±çš„ï¼Œæˆ‘ä»¬å¯ä»¥å…ˆåŠ è¿›å»ä½†ä¸é‡ç»˜ï¼Œæˆ–è€…é»˜é»˜åŠ è¿›å»
        window.cyGraph.add(allNodes);
        console.log(`å·²é¢„åŠ è½½ ${allNodes.length} ä¸ªèŠ‚ç‚¹ï¼Œé˜²æ­¢ä¾èµ–æŠ¥é”™ã€‚`);

        // 3. ç¬¬äºŒæ­¥ï¼šé€æ­¥åŠ è½½è¿çº¿ (åŠ¨ç”»è¿‡ç¨‹)
        let currentIndex = 0;

        function renderNextBatch() {
            try {
                // ç»“æŸæ¡ä»¶
                if (currentIndex >= pathwayNames.length) {
                    finishLoading();
                    return;
                }

                const pName = pathwayNames[currentIndex];
                const edgesBatch = edgesByPathway[pName];

                // æ›´æ–° UI
                const percent = Math.round(((currentIndex + 1) / pathwayNames.length) * 100);
                if(progressBar) progressBar.style.width = `${percent}%`;
                if(progressText) progressText.innerText = `Linking: ${pName} (${currentIndex + 1}/${pathwayNames.length})`;

                // æ·»åŠ è¿™æ‰¹è¿çº¿
                if (edgesBatch && edgesBatch.length > 0) {
                    window.cyGraph.batch(() => {
                        window.cyGraph.add(edgesBatch);
                    });
                }

                currentIndex++;
                // ç»§ç»­ä¸‹ä¸€å¸§
                requestAnimationFrame(renderNextBatch);

            } catch (err) {
                console.error("åŠ è½½è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯ï¼Œè·³è¿‡è¯¥æ‰¹æ¬¡ç»§ç»­:", err);
                // å¦‚æœå‡ºé”™ï¼Œå¼ºåˆ¶ç»§ç»­ä¸‹ä¸€é¡¹ï¼Œé˜²æ­¢å¡æ­»
                currentIndex++;
                requestAnimationFrame(renderNextBatch);
            }
        }

        // 4. æ”¶å°¾å·¥ä½œ
                // 4. æ”¶å°¾å·¥ä½œ
        function finishLoading() {
            if(progressText) progressText.innerText = "Please Wait a Minute...";
            
            setTimeout(() => {
                // å°è¯•è‡ªåŠ¨æ¢å¤ä¸Šä¸€æ¬¡å¸ƒå±€ï¼ˆè‹¥æˆåŠŸï¼Œåˆ™ä½¿ç”¨ preset å¸ƒå±€é¿å…é‡æ’ï¼‰
                const restored = restoreLayoutAuto && restoreLayoutAuto();

                // å®šä¹‰å¸ƒå±€å‚æ•°
                const layoutConfig = {
                    name: restored ? 'preset' : 'dagre',
                    rankDir: 'TB', // ä»ä¸Šåˆ°ä¸‹
                    padding: 50,   // ç•™ç‚¹ç™½è¾¹
                    fit: true,     // å¸ƒå±€ç»“æŸåè®©å›¾å……æ»¡å±å¹•
                    animate: false // å…³é—­å¸ƒå±€åŠ¨ç”»ï¼Œç›´æ¥æ˜¾ç¤ºç»“æœ
                };

                const layout = window.cyGraph.layout(layoutConfig);

                // ã€æ ¸å¿ƒä¿®æ”¹ã€‘ç›‘å¬å¸ƒå±€ç»“æŸäº‹ä»¶
                layout.on('layoutstop', () => {
                    const cy = window.cyGraph;
                    // ç»‘å®šå‰¯å°åˆ†å­äº¤äº’ï¼ˆå¤šé€‰ï¼‰
                    bindSideInteractionsOnce();
                    // ==========================================
                    // ã€æ ¸å¿ƒä¿®æ”¹ã€‘åœ¨æ­¤å¤„è°ƒç”¨å¯¹é½å‡½æ•°
                    // ==========================================
                    refreshSideVisibility(); 
                    refreshTransportVisibility();
                    // ==========================================

                    // é‡æ–°é€‚é…è§†å›¾å¤§å° (å› ä¸ºèŠ‚ç‚¹ä½ç½®å˜äº†)
                    cy.fit(cy.elements(), 50);

                    // è‡ªåŠ¨ä¿å­˜ä¸€æ¬¡ï¼ˆåˆæ¬¡å¸ƒå±€/æ¢å¤å®Œæˆåï¼‰
                    autoSaveLayoutDebounced();

                    // 1. è·å–å½“å‰â€œå…¨å±å±•ç¤ºâ€æ—¶çš„ç¼©æ”¾æ¯”ä¾‹
                    // å› ä¸º fit:true å·²ç»æ‰§è¡Œï¼Œç°åœ¨çš„ zoom å°±æ˜¯åˆšå¥½èƒ½çœ‹å…¨çš„å¤§å°
                    const fitZoom = cy.zoom();

                    // 2. è®¾ç½®åŠ¨æ€ç¼©æ”¾é™åˆ¶
                    // æœ€å°åªå…è®¸ç¼©æ”¾åˆ°â€œå…¨å›¾çš„ä¸€åŠå¤§â€ï¼Œä¸èƒ½å†å°äº†
                    cy.minZoom(fitZoom * 1);
                    // æœ€å¤§å…è®¸æ”¾å¤§ 5 å€
                    cy.maxZoom(fitZoom * 50); // ä¹‹å‰çš„ maxZoom å¦‚æœæ˜¯å›ºå®šæ•°å­—å¯èƒ½ä¸å‡†ï¼Œç°åœ¨æ˜¯ç›¸å¯¹å€¼

                    // 3. è®¾ç½®å¹³ç§»é™åˆ¶ï¼ˆä¸è®©å›¾è·‘å‡ºå±å¹•ï¼‰
                    // ç»‘å®š viewport äº‹ä»¶ï¼Œæ¯æ¬¡ç”¨æˆ·æ‹–æ‹½/ç¼©æ”¾æ—¶æ£€æŸ¥
                    cy.on('viewport', function() {
                        const pan = cy.pan();
                        const zoom = cy.zoom();
                        const width = cy.width();
                        const height = cy.height();
                        
                        // è·å–æ•´ä¸ªå›¾å…¶å®é™…å æ®çš„ç‰©ç†èŒƒå›´
                        const bb = cy.elements().boundingBox();
                        
                        // è®¡ç®—è¾¹ç•Œï¼ˆå…è®¸ç•™ç™½ä¸€ç‚¹ç‚¹ï¼Œä½†ä¸å…è®¸å®Œå…¨è·‘å‡ºå»ï¼‰
                        // ä¸‹é¢çš„é€»è¾‘ç¡®ä¿å›¾çš„è¾¹ç¼˜è‡³å°‘æœ‰ä¸€éƒ¨åˆ†åœ¨å±å¹•å†…
                        const gutter = 100; // ç¼“å†²åŒºåƒç´ 

                        // ç®€å•çš„â€œå›å¼¹â€é€»è¾‘ä¼šé€ æˆæŠ–åŠ¨ï¼Œæ‰€ä»¥æˆ‘ä»¬åªé™åˆ¶èŒƒå›´
                        // ä¸‹é¢æ˜¯æ¯”è¾ƒé€šç”¨çš„é™åˆ¶é€»è¾‘ï¼Œä¸éœ€è¦æ·±ç©¶æ•°å­¦åŸç†
                        // æ ¸å¿ƒæ€æƒ³ï¼šå¦‚æœPanå¾—å¤ªè¿œï¼Œå°±å¼ºåˆ¶æ‹‰å›æ¥
                        
                        // è®¡ç®—åˆæ³•çš„ Pan èŒƒå›´
                        // è¿™é‡Œçš„é€»è¾‘ç¨å¾®å¤æ‚ï¼Œç›®çš„æ˜¯è®©å›¾çš„å†…å®¹å§‹ç»ˆä¿ç•™åœ¨ viewport å†…
                        
                        // ç®€æ˜“ç‰ˆé™åˆ¶ï¼šé™åˆ¶å›¾çš„ä¸­å¿ƒç‚¹ä¸èƒ½è·‘å‡ºå±å¹•
                        const graphCenterX = (bb.x1 + bb.w/2) * zoom + pan.x;
                        const graphCenterY = (bb.y1 + bb.h/2) * zoom + pan.y;
                        
                        // å¦‚æœä¸­å¿ƒç‚¹è·‘å¤ªè¿œäº†ï¼Œå°±å¼ºè¡Œé‡ç½® Pan
                        // è¿™é‡Œä¸åšå¼ºåˆ¶è¦†ç›–ï¼ŒCytoscape æ²¡æœ‰å†…ç½® bounds é™åˆ¶
                        // è¿™æ˜¯ä¸€ä¸ªæŠ˜ä¸­æ–¹æ¡ˆï¼šå¦‚æœæ£€æµ‹åˆ°è¿ boundingbox éƒ½çœ‹ä¸åˆ°äº†ï¼Œå°± fit å›å»
                        // ä½†è¿™ä½“éªŒä¸å¥½ã€‚
                    });
                    
                    // ã€å¼ºçƒˆæ¨èã€‘ä½¿ç”¨ containment é€»è¾‘ä»£æ›¿ä¸Šé¢çš„æ‰‹åŠ¨è®¡ç®—
                    // Cytoscape æ²¡æœ‰å†…ç½® containmentï¼Œæœ€ç¨³å¦¥çš„æ–¹æ³•æ˜¯é™åˆ¶ minZoom (ä¸Šé¢å·²åš)
                    // åªè¦ minZoom è¶³å¤Ÿå¤§ï¼Œç”¨æˆ·å°±æ°¸è¿œæ— æ³•æŠŠå›¾å˜å¼„ä¸¢ã€‚
                    
                    // ç§»é™¤é®ç½©
                    if(loadingMask) {
                        loadingMask.style.opacity = '0';
                        setTimeout(() => {
                            loadingMask.style.display = 'none';
                        }, 500);
                    }
                });

                layout.run();
                
                if(typeof initSearchListener === 'function') initSearchListener();
            }, 100);
        }


        // å¯åŠ¨å¾ªç¯
        renderNextBatch();
    }




    // ============================================================
    // 3. æ ¸å¿ƒç®—æ³•ï¼šç²¾ç¡®å‡ ä½•å®šä½ + æ··åˆçº¿å‹ (recalculateCurves)
    // ============================================================
    const recalculateCurves = () => {
        const currentCy = window.cyGraph || window.cy;
        if (!currentCy) return;

        currentCy.batch(() => {
            // å‚æ•°é…ç½®
            const GAP_X = 25;      // å‰¯èŠ‚ç‚¹ä¸ä¸»èŠ‚ç‚¹è¾¹ç¼˜çš„é—´è·
            const STEP_Y = 40;     // å‰¯èŠ‚ç‚¹çš„å‚ç›´å¯¹é½æ­¥é•¿

            currentCy.nodes('[type="reaction"]').forEach(rxnNode => {
                const center = rxnNode.position(); 
                const rxnW = rxnNode.outerWidth();
                
                // --- 1. å®šä½å·¦ä¾§å‰¯ååº”ç‰© (Side Inputs) ---
                const sideInEdges = rxnNode.incomers('edge[edgeType="side"]');
                const sideInNodes = sideInEdges.sources();
                
                if (sideInNodes.length > 0) {
                    const totalHeight = (sideInNodes.length - 1) * STEP_Y;
                    const startY = center.y - (totalHeight / 2);

                    sideInNodes.forEach((node, i) => {
                        const nodeW = node.outerWidth(); 
                        // å…¬å¼ï¼šCenter - RxnHalf - Gap - NodeHalf
                        const targetX = center.x - (rxnW / 2) - GAP_X - (nodeW / 2);
                        node.position({ x: targetX, y: startY + (i * STEP_Y) });
                    });
                }

                // --- 2. å®šä½å³ä¾§å‰¯äº§ç‰© (Side Outputs) ---
                const sideOutEdges = rxnNode.outgoers('edge[edgeType="side"]');
                const sideOutNodes = sideOutEdges.targets();

                if (sideOutNodes.length > 0) {
                    const totalHeight = (sideOutNodes.length - 1) * STEP_Y;
                    const startY = center.y - (totalHeight / 2);

                    sideOutNodes.forEach((node, i) => {
                        const nodeW = node.outerWidth();
                        // å…¬å¼ï¼šCenter + RxnHalf + Gap + NodeHalf
                        const targetX = center.x + (rxnW / 2) + GAP_X + (nodeW / 2);
                        node.position({ x: targetX, y: startY + (i * STEP_Y) });
                    });
                }

                // --- 3. è®¡ç®—ä¸»å¹²æµå‘å‘é‡ (Main Flow Vector) ---
                const mainInEdges = rxnNode.incomers('edge[edgeType="main"]');
                const mainOutEdges = rxnNode.outgoers('edge[edgeType="main"]');

                // é»˜è®¤å‘é‡ (0,1) å‘ä¸‹
                let flowVec = { x: 0, y: 1 }; 

                // åªæœ‰ä¸»å¹²æ‰å‚ä¸å‘é‡è®¡ç®—
                if (mainInEdges.length > 0 || mainOutEdges.length > 0) {
                    const getCentroid = (edges, type) => {
                        let x = 0, y = 0;
                        if (edges.length === 0) return center;
                        edges.forEach(e => {
                            const p = type === 'in' ? e.source().position() : e.target().position();
                            x += p.x; y += p.y;
                        });
                        return { x: x / edges.length, y: y / edges.length };
                    };

                    const upstreamP = getCentroid(mainInEdges, 'in');
                    const downstreamP = getCentroid(mainOutEdges, 'out');

                    let dx = downstreamP.x - upstreamP.x;
                    let dy = downstreamP.y - upstreamP.y;
                    const len = Math.sqrt(dx * dx + dy * dy);

                    if (len > 0.1) {
                        flowVec = { x: dx / len, y: dy / len };
                    }
                }

                // --- 4. åˆ†ç±»åº”ç”¨æ ·å¼ ---
                
                // è´å¡å°”æ§åˆ¶ç‚¹è®¡ç®—å‡½æ•°
                const calcBezierDist = (pStart, pEnd) => {
                    const mid = { x: (pStart.x + pEnd.x)/2, y: (pStart.y + pEnd.y)/2 };
                    const seg = { x: pEnd.x - pStart.x, y: pEnd.y - pStart.y };
                    const perp = { x: -seg.y, y: seg.x }; // å‚ç›´å‘é‡
                    const perpLen = Math.sqrt(perp.x*perp.x + perp.y*perp.y);
                    if (perpLen < 0.01) return 0;
                    const perpNorm = { x: perp.x/perpLen, y: perp.y/perpLen };

                    // æŠ•å½±
                    const a1 = perpNorm.x, b1 = -flowVec.x, c1 = center.x - mid.x;
                    const a2 = perpNorm.y, b2 = -flowVec.y, c2 = center.y - mid.y;
                    const det = a1 * b2 - a2 * b1;
                    
                    if (Math.abs(det) < 0.001) return 0;
                    let dist = (c1 * b2 - c2 * b1) / det;
                    
                    if (Math.abs(dist) > 300) dist = dist > 0 ? 300 : -300;
                    return Math.abs(dist) < 2 ? 0 : dist;
                };

                // å¤„ç†å…¥è¾¹
                rxnNode.incomers('edge').forEach(edge => {
                    if (edge.data('edgeType') === 'main') {
                        const dist = calcBezierDist(edge.source().position(), center);
                        edge.style({
                            'curve-style': 'unbundled-bezier',
                            'control-point-distances': dist,
                            'control-point-weights': 0.5 
                        });
                    } else {
                        // å‰¯ååº”ï¼šç›´çº¿
                        edge.style({
                            'curve-style': 'straight', 
                            'target-arrow-shape': 'none' 
                        });
                    }
                });

                // å¤„ç†å‡ºè¾¹
                rxnNode.outgoers('edge').forEach(edge => {
                    if (edge.data('edgeType') === 'main') {
                        const dist = calcBezierDist(center, edge.target().position());
                        edge.style({
                            'curve-style': 'unbundled-bezier',
                            'control-point-distances': dist,
                            'control-point-weights': 0.5
                        });
                    } else {
                        // å‰¯ååº”ï¼šç›´çº¿
                        edge.style({
                            'curve-style': 'straight'
                        });
                    }
                });
            });
        });
    };

    // ============================================================
    // 4. å³ä¾§ç­›é€‰é€»è¾‘ (Filter)
    // ============================================================
    function generateCheckboxes(pathwaysBySheet) {
        const container = document.getElementById('filter-container');
        container.innerHTML = '';

        // Global Select All
        const globalDiv = document.createElement('label');
        globalDiv.className = 'checkbox-item';
        globalDiv.innerHTML = `<input type="checkbox" id="check-all-global" checked> <b>(Select All)</b>`;
        container.appendChild(globalDiv);

        // Clear selected side-molecules (only from reaction selection)
        const clearBtn = document.createElement('button');
        clearBtn.id = 'clear-selected-side';
        clearBtn.className = 'side-action-btn';
        clearBtn.textContent = 'Clear selected molecules';
        clearBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (window.selectedReactionIds) window.selectedReactionIds.clear();
            refreshSideVisibility();
        });
        container.appendChild(clearBtn);


        const buildSheetGroup = (sheetName) => {
            const group = document.createElement('div');
            group.className = 'sheet-group';

            const header = document.createElement('div');
            header.className = 'sheet-header';
            header.innerHTML = `
                <div class="sheet-name">
                    <span class="sheet-swatch" style="background:${SHEET_COLORS[sheetName] || '#95a5a6'}"></span>
                    <span>${sheetName}</span>
                </div>
            `;

            const selectAll = document.createElement('label');
            selectAll.className = 'checkbox-item sheet-selectall';
            selectAll.innerHTML = `<input type="checkbox" class="check-all-sheet" data-sheet="${sheetName}" checked> <b>(Select All)</b>`;
            header.appendChild(selectAll);

            const body = document.createElement('div');
            body.className = 'sheet-body';

            group.appendChild(header);
            group.appendChild(body);

            return { group, body, selectAllInput: selectAll.querySelector('input') };
        };

        // Render groups in TARGET_SHEETS order
        const sheetGroups = new Map();
        TARGET_SHEETS.forEach(sheet => {
            const { group, body, selectAllInput } = buildSheetGroup(sheet);
            sheetGroups.set(sheet, { body, selectAllInput });
            container.appendChild(group);
        });

        // Fill pathways (keep sheet order as collected)
        TARGET_SHEETS.forEach(sheet => {
            const list = (pathwaysBySheet && pathwaysBySheet.get) ? (pathwaysBySheet.get(sheet) || []) : [];
            const { body } = sheetGroups.get(sheet) || {};
            if (!body) return;

            if (!list || list.length === 0) {
                const empty = document.createElement('div');
                empty.style.cssText = 'color:#999;font-size:12px;padding:4px 6px;font-style:italic;';
                empty.textContent = '(No pathway)';
                body.appendChild(empty);
                return;
            }

            list.forEach(pw => {
                const label = document.createElement('label');
                label.className = 'checkbox-item';
                label.innerHTML = '';
                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.className = 'pw-check';
                cb.value = pw;
                cb.dataset.sheet = sheet;
                cb.checked = true;

                const text = document.createElement('span');
                text.className = 'pw-text';
                text.textContent = toTitleCase(pw);

                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'side-toggle-btn';
                btn.dataset.pathway = pw;
                btn.textContent = 'Pin Side';
                btn.title = 'Pin/unpin side molecules for this pathway';
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const p = btn.dataset.pathway;
                    if (!window.pinnedSidePathways) window.pinnedSidePathways = new Set();
                    if (window.pinnedSidePathways.has(p)) {
                        window.pinnedSidePathways.delete(p);
                        btn.classList.remove('active');
                    } else {
                        window.pinnedSidePathways.add(p);
                        btn.classList.add('active');
                    }
                    refreshSideVisibility();
                });

                label.appendChild(cb);
                label.appendChild(text);
                label.appendChild(btn);
                body.appendChild(label);
            });
        });

        const allPwChecks = () => Array.from(container.querySelectorAll('.pw-check'));
        const updateGlobalState = () => {
            const boxes = allPwChecks();
            const allChecked = boxes.length > 0 && boxes.every(cb => cb.checked);
            document.getElementById('check-all-global').checked = allChecked;
        };
        const updateSheetState = (sheet) => {
            const boxes = allPwChecks().filter(cb => cb.dataset.sheet === sheet);
            const allChecked = boxes.length > 0 && boxes.every(cb => cb.checked);
            const g = sheetGroups.get(sheet);
            if (g && g.selectAllInput) g.selectAllInput.checked = allChecked;
        };

        // Bind global select all
        globalDiv.querySelector('input').addEventListener('change', (e) => {
            const isChecked = e.target.checked;
            allPwChecks().forEach(cb => cb.checked = isChecked);
            TARGET_SHEETS.forEach(updateSheetState);
            filterGraph();
        });

        // Bind per-sheet select all
        TARGET_SHEETS.forEach(sheet => {
            const g = sheetGroups.get(sheet);
            if (!g) return;
            g.selectAllInput.addEventListener('change', (e) => {
                const isChecked = e.target.checked;
                allPwChecks()
                    .filter(cb => cb.dataset.sheet === sheet)
                    .forEach(cb => cb.checked = isChecked);
                updateGlobalState();
                filterGraph();
            });
        });

        // Bind per-pathway
        allPwChecks().forEach(cb => {
            cb.addEventListener('change', () => {
                updateSheetState(cb.dataset.sheet);
                updateGlobalState();
                filterGraph();
            });
        });

        // Initial state
        TARGET_SHEETS.forEach(updateSheetState);
        updateGlobalState();
        setTimeout(filterGraph, 100);
    }


    
    // æ ¹æ®å½“å‰é€‰ä¸­çš„ Pathwayï¼ŒåŠ¨æ€åˆ·æ–°ä¸»å¹²åˆ†å­ï¼ˆMain Reactant / Main Productï¼‰çš„é¢œè‰²
    function updateMainMoleculeColors(selectedPathways) {
        const cy = window.cyGraph || window.cy;
        const metaMap = window.mainMoleculeMeta;
        if (!cy || !metaMap) return;

        cy.nodes('.main-molecule').forEach(n => {
            const meta = metaMap.get(n.data('baseName') || n.id());
            if (!meta) return;

            // è‹¥é€‰ä¸­äº† Pathwayï¼šä¼˜å…ˆç”¨è¯¥åˆ†å­åœ¨â€œè¢«é€‰ä¸­ Pathwayâ€å¯¹åº”çš„ sheet é¢œè‰²
            if (selectedPathways && selectedPathways.length > 0) {
                const candidate = new Set();
                selectedPathways.forEach(pw => {
                    const sset = meta.pathwaySheets.get(pw);
                    if (sset) sset.forEach(s => candidate.add(s));
                });
                if (candidate.size > 0) {
                    n.data('color', pickSheetColor(candidate));
                    return;
                }
            }

            // å¦åˆ™ï¼šæŒ‰åˆ†å­å…¨å±€å‡ºç°çš„ sheets å–é»˜è®¤é¢œè‰²ï¼ˆæŒ‰ä¼˜å…ˆçº§ï¼‰
            n.data('color', pickSheetColor(meta.sheets));
        });
    }

function filterGraph() {
        const currentCy = window.cyGraph || window.cy;
        if (!currentCy) return;

        const checkboxes = document.querySelectorAll('.pw-check');
        const selectedPathways = Array.from(checkboxes)
            .filter(cb => cb.checked)
            .map(cb => cb.value);

        // è®°å½•å½“å‰å‹¾é€‰çš„ pathwayï¼ˆå‰¯å°åˆ†å­æ˜¾ç¤ºä¹Ÿéœ€è¦ç”¨åˆ°ï¼‰
        window.__selectedPathwaysSet = new Set(selectedPathways);

        currentCy.batch(() => {
            const allElements = currentCy.elements();
            allElements.removeClass('highlighted').addClass('dimmed');

            if (selectedPathways.length === 0) {
                // é¢œè‰²å›é€€åˆ°é»˜è®¤ï¼ˆæŒ‰åˆ†å­å…¨å±€å‡ºç°çš„ sheetsï¼‰
                updateMainMoleculeColors([]);
                return;
            }

            const activeEdges = currentCy.edges().filter(edge => {
                const pData = edge.data('pathway');
                if (!pData) return false;
                return selectedPathways.includes(pData);
            });

            activeEdges.removeClass('dimmed').addClass('highlighted');
            activeEdges.connectedNodes().removeClass('dimmed').addClass('highlighted');

            // åŒæ­¥åˆ·æ–°ä¸»å¹²åˆ†å­é¢œè‰²ï¼ˆé€‰ä¸­ Pathway æ—¶æŒ‰è¯¥ Pathway æ‰€å± sheet ä¸Šè‰²ï¼‰
            updateMainMoleculeColors(selectedPathways);
        });

        // ä¾§è¾¹æ ç­›é€‰å˜åŒ–åï¼Œæ›´æ–°å‰¯å°åˆ†å­å’Œè·¨è†œè¿è¾“è¾¹çš„æ˜¾ç¤º
        refreshSideVisibility();
        refreshTransportVisibility();

    }

    // è¾…åŠ©å·¥å…·
    function showStatus(msg) { document.getElementById('status').innerText = msg; }
    function updateStatus(text) { document.getElementById('status').innerText = text; }

    // ============================================================
    // 4b. å‰¯å°åˆ†å­æ˜¾ç¤ºé€»è¾‘ï¼šé»˜è®¤éšè—ï¼ŒæŒ‰éœ€å›´ç»•é…¶èŠ‚ç‚¹å±•å¼€
    // ============================================================
    function refreshSideVisibility() {
        const cy = window.cyGraph;
        if (!cy) return;

        const selectedPathways = window.__selectedPathwaysSet || new Set();
        const pinned = window.pinnedSidePathways || new Set();
        const selectedRxns = window.selectedReactionIds || new Set();

        cy.batch(() => {
            // å…ˆå…¨éƒ¨éšè—
            cy.nodes('.side-molecule').addClass('hidden-side');
            cy.edges('.edge-side').addClass('hidden-side');

            // å†æŒ‰â€œå›ºå®šæ‰“å¼€çš„ pathwayâ€æ˜¾ç¤º
            cy.nodes('[type="reaction"]').forEach(rxn => {
                const pw = rxn.data('pathway');
                if (!pw) return;
                // åªåœ¨è¯¥ pathway ä»ç„¶è¢«å‹¾é€‰æ—¶å±•å¼€ï¼ˆé¿å…ä¸è¿‡æ»¤å†²çªï¼‰
                if (pinned.has(pw) && (selectedPathways.size === 0 || selectedPathways.has(pw))) {
                    showSideForReaction(rxn.id());
                }
            });

            // å†æŒ‰â€œç‚¹é€‰çš„ååº”â€æ˜¾ç¤ºï¼ˆå…è®¸å¤šä¸ªå…±å­˜ï¼‰
            selectedRxns.forEach(rxnId => {
                showSideForReaction(rxnId);
            });
        });

        // æ˜¾ç¤ºåå†ç»Ÿä¸€å¯¹é½ï¼Œé¿å…æ•£è½/é‡å ï¼ˆå†»ç»“çŠ¶æ€ä¸è‡ªåŠ¨æŒªåŠ¨èŠ‚ç‚¹ï¼‰
        if (!window.__uiFrozen) alignSideNodes();
}

    function refreshTransportVisibility() {
        const cy = window.cyGraph;
        if (!cy) return;

        const selectedPathways = window.__selectedPathwaysSet || new Set();
        const globalCheckbox = document.getElementById('check-all-global');
        const isGlobalAllChecked = !!(globalCheckbox && globalCheckbox.checked);

        cy.batch(() => {
            const allTransEdges = cy.edges('.edge-transport');

            // å…ˆå…¨éƒ¨æ˜¾ç¤ºï¼Œå†æŒ‰è§„åˆ™å»â€œæ‰“éšè—æ ‡è®°â€
            allTransEdges.removeClass('hidden-transport');

            // æƒ…å†µ 1ï¼šå…¨é€‰çŠ¶æ€ - æ‰€æœ‰è·¨è†œè¾¹éƒ½æ˜¾ç¤ºä¸ºæµ…ç°è™šçº¿
            if (isGlobalAllChecked) {
                return;
            }

            // æƒ…å†µ 2ï¼šæ²¡æœ‰ä»»ä½• Pathway è¢«é€‰ä¸­ - å…¨éƒ¨éšè—
            if (!selectedPathways || selectedPathways.size === 0) {
                allTransEdges.addClass('hidden-transport');
                return;
            }

            // å°å·¥å…·ï¼šåˆ¤æ–­ä¸€ä¸ªåˆ†å­èŠ‚ç‚¹æ˜¯å¦â€œå‚ä¸äº†é€‰ä¸­ Pathwayâ€
            const inSelectedPathway = (node) => {
                let flag = false;
                node.neighborhood('node[type="reaction"]').forEach(rxn => {
                    if (flag) return;
                    const pw = rxn.data('pathway');
                    if (pw && selectedPathways.has(pw)) {
                        flag = true;
                    }
                });
                return flag;
            };

            // æƒ…å†µ 3ï¼šéƒ¨åˆ† Pathway è¢«é€‰ä¸­ - åªæœ‰ä¸¤ç«¯éƒ½â€œå±äºé€‰ä¸­ Pathwayâ€çš„æ‰æ˜¾ç¤º
            allTransEdges.forEach(edge => {
                const src = edge.source();
                const tgt = edge.target();

                const srcOk = inSelectedPathway(src);
                const tgtOk = inSelectedPathway(tgt);

                if (!(srcOk && tgtOk)) {
                    edge.addClass('hidden-transport');
                }
            });
        });
    }


    function showSideForReaction(rxnId) {
        const cy = window.cyGraph;
        if (!cy) return;

        // side nodes çš„ id éƒ½ä»¥ `${rxnId}_side_` å¼€å¤´
        cy.nodes('.side-molecule').forEach(n => {
            if (n.id().startsWith(`${rxnId}_side_`)) {
                n.removeClass('hidden-side');
            }
        });

        // side edgesï¼šè¿æ¥ååº”èŠ‚ç‚¹ä¸ side node
        cy.edges('.edge-side').forEach(e => {
            const s = e.data('source');
            const t = e.data('target');
            if ((typeof s === 'string' && s.startsWith(`${rxnId}_side_`)) ||
                (typeof t === 'string' && t.startsWith(`${rxnId}_side_`))) {
                e.removeClass('hidden-side');
            }
        });
    }

    function bindSideInteractionsOnce() {
        const cy = window.cyGraph;
        if (!cy) return;
        if (cy.__sideBound) return;
        cy.__sideBound = true;

        // ç‚¹é€‰ååº”/é…¶èŠ‚ç‚¹ï¼šæ”¯æŒå¤šé€‰ï¼Œä¸ä¼šè®©ä¹‹å‰çš„æ¶ˆå¤±
        cy.on('tap', 'node[type="reaction"]', (evt) => {
            const id = evt.target.id();
            if (!window.selectedReactionIds) window.selectedReactionIds = new Set();
            if (window.selectedReactionIds.has(id)) window.selectedReactionIds.delete(id);
            else window.selectedReactionIds.add(id);
            refreshSideVisibility();
            autoSaveLayoutDebounced();
        });

        // æ‹–åŠ¨ååº”èŠ‚ç‚¹æ—¶ï¼Œå‰¯å°åˆ†å­è·Ÿéšæ’å¸ƒ
        let _raf = null;
        cy.on('drag', 'node[type="reaction"]', () => {
            if (_raf) cancelAnimationFrame(_raf);
            _raf = requestAnimationFrame(() => { if (!window.__uiFrozen) alignSideNodes(); });
        });
        cy.on('dragfree', 'node', () => {
            if (!window.__uiFrozen) alignSideNodes();
            autoSaveLayoutDebounced();
        });
    }

    // ============================================================
    // 4c. è‡ªåŠ¨ä¿å­˜/æ¢å¤å¸ƒå±€ï¼ˆé¿å…æ¯æ¬¡éƒ½é‡è°ƒä½ç½®ï¼‰
    // ============================================================
    const STORAGE_KEY_AUTO = STORAGE_KEY + '_autosave';

    function saveLayoutAuto() {
        if (!window.cyGraph) return;
        const positions = {};
        window.cyGraph.nodes().forEach(node => {
            positions[node.id()] = node.position();
        });
        localStorage.setItem(STORAGE_KEY_AUTO, JSON.stringify(positions));
    
        saveLayoutToServer(positions);
}

    function restoreLayoutAuto() {
        const raw = localStorage.getItem(STORAGE_KEY_AUTO);
        if (!raw || !window.cyGraph) return false;

        let positions = null;
        try {
            positions = JSON.parse(raw);
        } catch {
            return false;
        }
        if (!positions || typeof positions !== 'object') return false;

        const cy = window.cyGraph;
        const restoredIds = new Set();

        // 1) å…ˆæŠŠå·²æœ‰è®°å½•çš„èŠ‚ç‚¹æ”¾å›åŸä½
        cy.nodes().forEach(node => {
            const p = positions[node.id()];
            if (p && typeof p.x === 'number' && typeof p.y === 'number') {
                node.position({ x: p.x, y: p.y });
                restoredIds.add(node.id());
            }
        });

        // 2) å¯¹â€œæ–°èŠ‚ç‚¹â€ï¼Œå°½é‡é å·²æœ‰èŠ‚ç‚¹æ‘†æ”¾ï¼Œä¸åŠ¨è€èŠ‚ç‚¹
        cy.nodes().forEach(node => {
            if (restoredIds.has(node.id())) return;  // åªå¤„ç†æ–°èŠ‚ç‚¹

            let sumX = 0;
            let sumY = 0;
            let cnt = 0;

            // åœ¨é‚»æ¥èŠ‚ç‚¹é‡Œæ‰¾å·²ç»æœ‰ä½ç½®çš„èŠ‚ç‚¹
            node.neighborhood('node').forEach(nb => {
                if (!restoredIds.has(nb.id())) return;
                const bp = nb.position();
                if (typeof bp.x === 'number' && typeof bp.y === 'number') {
                    sumX += bp.x;
                    sumY += bp.y;
                    cnt += 1;
                }
            });

            if (cnt > 0) {
                const avgX = sumX / cnt;
                const avgY = sumY / cnt;
                // åœ¨é‚»å±…é™„è¿‘ç¨å¾®åç§»ä¸€ç‚¹ï¼Œé¿å…å®Œå…¨é‡åˆ
                node.position({ x: avgX + 40, y: avgY });
            }
            // å¦‚æœå®Œå…¨æ‰¾ä¸åˆ°æœ‰åæ ‡çš„é‚»å±…ï¼Œå°±ä¿æŒé»˜è®¤ä½ç½®ï¼Œåç»­ä½ å¯ä»¥æ‰‹åŠ¨æ‹–åŠ¨å†ä¿å­˜
        });

        // è®°å½•ä¸€ä¸‹å“ªäº›èŠ‚ç‚¹æ˜¯â€œè€èŠ‚ç‚¹â€
        window.__layoutRestoredNodes = restoredIds;

        return restoredIds.size > 0;
    }

    let _saveTimer = null;
    function autoSaveLayoutDebounced() {
        if (_saveTimer) clearTimeout(_saveTimer);
        _saveTimer = setTimeout(() => {
            try { saveLayoutAuto(); } catch(e) {}
        }, 250);
    }

    window.addEventListener('beforeunload', () => {
        try { saveLayoutAuto(); } catch(e) {}
    });

function showError(msg) {
    const el = document.getElementById('error-msg');
    el.style.display = 'block';
    el.innerHTML = 'âŒ ' + msg;
}
// ... ä½ çš„å…¶ä»–ä»£ç  ...
    // ============================================================
    // 5. ã€æ–°å¢ã€‘å‰¯èŠ‚ç‚¹å¼ºåˆ¶å¯¹é½ç®—æ³• (è®©å‰¯äº§ç‰©ç´§è´´ååº”èŠ‚ç‚¹)
    // ============================================================
    function alignSideNodes() {
        const cy = window.cyGraph;
        if (!cy) return;

        cy.batch(() => {
            // æ›´ç¾è§‚çš„æ’å¸ƒï¼šè¿œç¦»é…¶èŠ‚ç‚¹ï¼Œä¸”å¤šå°åˆ†å­æ—¶é‡‡ç”¨â€œå¤šåˆ—æ …æ ¼â€
            const OFFSET_X = 160;    // æ¨ªå‘è·ç¦»ï¼šè®©å‡ºé…¶èŠ‚ç‚¹æ–‡å­—åŒºåŸŸ
            const STEP_Y  = 26;      // è¡Œé—´è·
            const MAX_PER_COL = 6;   // å•åˆ—æœ€å¤šæ”¾å¤šå°‘ä¸ª
            const COL_GAP = 70;      // å¤šåˆ—æ—¶åˆ—é—´è·

            const isVisibleSide = (n) => !n.hasClass('hidden-side');

            cy.nodes('[type="reaction"]').forEach(rxnNode => {
                const center = rxnNode.position();
                const rxnId = rxnNode.id();

                // åªå¤„ç†â€œå½“å‰å¯è§â€çš„å‰¯å°åˆ†å­
                const inNodes = [];
                const outNodes = [];

                cy.nodes('.side-molecule').forEach(n => {
                    if (!isVisibleSide(n)) return;
                    if (n.data('parentRxn') !== rxnId) return;
                    if (n.data('role') === 'in') inNodes.push(n);
                    if (n.data('role') === 'out') outNodes.push(n);
                });

                const placeGrid = (nodes, side) => {
                    const total = nodes.length;
                    if (total === 0) return;

                    const cols = Math.ceil(total / MAX_PER_COL);
                    for (let c = 0; c < cols; c++) {
                        const start = c * MAX_PER_COL;
                        const chunk = nodes.slice(start, start + MAX_PER_COL);
                        const rows = chunk.length;

                        // å·¦ä¾§å‘å·¦æ‰©å±•ï¼Œå³ä¾§å‘å³æ‰©å±•
                        const x = (side === 'left')
                            ? (center.x - OFFSET_X - c * COL_GAP)
                            : (center.x + OFFSET_X + c * COL_GAP);

                        const y0 = center.y - (rows - 1) * STEP_Y / 2;

                        chunk.forEach((node, r) => {
                            node.position({
                                x: x,
                                y: y0 + r * STEP_Y
                            });
                        });
                    }
                };

                // è¾“å…¥æ”¾å·¦è¾¹ï¼Œè¾“å‡ºæ”¾å³è¾¹
                placeGrid(inNodes, 'left');
                placeGrid(outNodes, 'right');
            });
        });
    }

// åœ¨è„šæœ¬æœ€åå¯åŠ¨ç›‘å¬
initSearchListener();


/* =========================
   Organelle background editor
   ========================= */
const ORGANELLES = [
  { key: 'chloroplast', src: 'orgenells/chloroplast.jpg', label: 'Chloroplast',  x: 80,  y: 80,  w: 520, h: 380 },
  { key: 'er_smooth',   src: 'orgenells/ER smooth.jpg',   label: 'ER (Smooth)',  x: 140, y: 460, w: 560, h: 300 },
  { key: 'glyoxysome',  src: 'orgenells/glyoxysome.jpg',  label: 'Glyoxysome',   x: 760, y: 120, w: 360, h: 280 },
  { key: 'mitochondria',src: 'orgenells/mitochondria.jpg',label: 'Mitochondria', x: 760, y: 460, w: 420, h: 320 },
];

let organelleEditing = false;
// Coordinate mode:
// - 'surface': screen-space overlay (does NOT move/zoom with Cytoscape)
// - 'world'  : model-space (moves/zooms with Cytoscape)
// Coordinate mode:
// - 'world'  => organelles live in Cytoscape model coordinates, so they pan/zoom exactly with nodes.
//              We render them in a DOM overlay, but apply the same viewport matrix as Cytoscape.
// Requirement: organelles should move/scale with nodes and appear ABOVE them.
const ORGANELLE_COORD_MODE = 'world';

function organelleVersionForMode(){
  return (ORGANELLE_COORD_MODE === 'surface') ? 2 : 3;
}

let organelleState = { version: organelleVersionForMode(), opacity: 0.18, organelles: {} };
const ORG_LOCAL_KEY = 'organelle_layout_v2';
const ORG_LOCAL_KEY_V1 = 'organelle_layout_v1';

let organelleSelectedKey = null;

function getOrgBoxEl(key){
  const layer = document.getElementById('organelle-layer');
  if(!layer) return null;
  try{
    // CSS.escape may not exist in older browsers; fall back to a simple escape.
    const esc = (window.CSS && CSS.escape) ? CSS.escape(key) : String(key).replace(/"/g,'\\\"');
    return layer.querySelector(`.organelle-box[data-key="${esc}"]`);
  }catch(_){
    return layer.querySelector(`.organelle-box[data-key="${key}"]`);
  }
}

function selectOrganelle(key){
  organelleSelectedKey = key;
  const layer = document.getElementById('organelle-layer');
  if(layer){
    layer.querySelectorAll('.organelle-box').forEach(b => {
      b.classList.toggle('selected', b.dataset.key === key);
    });
  }
  updateOrganellePanelSelection();
}

function updateOrganellePanelSelection(){
  const labelEl = document.getElementById('organelle-selected-label');
  const rotInput = document.getElementById('organelle-rotate');
  const rotVal = document.getElementById('organelle-rotate-val');
  if(!labelEl || !rotInput || !rotVal) return;

  if(!organelleSelectedKey){
    labelEl.textContent = 'None';
    rotInput.disabled = true;
    rotInput.value = 0;
    rotVal.textContent = '0Â°';
    return;
  }

  labelEl.textContent = organelleSelectedKey;
  rotInput.disabled = false;

  const box = getOrgBoxEl(organelleSelectedKey);
  const rot = box
    ? (parseFloat(box.dataset.rot || '0') || 0)
    : (parseFloat(organelleState.organelles?.[organelleSelectedKey]?.r || '0') || 0);

  rotInput.value = Math.max(-180, Math.min(180, Math.round(rot)));
  rotVal.textContent = `${Math.round(rot)}Â°`;
}


function encodeOrgSrc(src){
  // Make filenames with spaces work across browsers
  return src.split('/').map(seg => encodeURIComponent(seg)).join('/');
}

async function loadOrganellesState(){
  // server -> localStorage -> defaults
  try{
    const r = await fetch('/api/organelles');
    if(r.ok){
      const data = await r.json();
      if(data && typeof data === 'object'){
        const ver = (typeof data.version === 'number') ? data.version : 1;
        organelleState = {
          version: ver,
          coordMode: (typeof data.coordMode === 'string') ? data.coordMode : undefined,
          opacity: typeof data.opacity === 'number' ? data.opacity : (data.opacity ? (data.opacity/100) : 0.18),
          organelles: data.organelles || {}
        };
        // Persist into the current local key (v2) so we can migrate transparently.
        localStorage.setItem(ORG_LOCAL_KEY, JSON.stringify(organelleState));
        return;
      }
    }
  }catch(e){}
  try{
    // Prefer v2; fall back to v1 if present.
    const raw2 = localStorage.getItem(ORG_LOCAL_KEY);
    if(raw2){ organelleState = JSON.parse(raw2); return; }
    const raw1 = localStorage.getItem(ORG_LOCAL_KEY_V1);
    if(raw1){ organelleState = JSON.parse(raw1); return; }
  }catch(e){}
  organelleState = { version: organelleVersionForMode(), coordMode: ORGANELLE_COORD_MODE, opacity: 0.18, organelles: {} };
}

function getOrgBoxConfig(key){
  const saved = organelleState.organelles?.[key];
  if(saved && typeof saved === 'object'){
    return saved;
  }
  const def = ORGANELLES.find(o => o.key === key);
  return { x: def.x, y: def.y, w: def.w, h: def.h, r: 0 };
}

function setOrgOpacity(alpha){
  const layer = document.getElementById('organelle-layer');
  layer.querySelectorAll('.organelle-box img').forEach(img => { img.style.opacity = String(alpha); });
}

function initOrganellesLayer(){
  const layer = document.getElementById('organelle-layer');
  layer.innerHTML = '';
  ORGANELLES.forEach(org => {
    const cfg = getOrgBoxConfig(org.key);

    const box = document.createElement('div');
    box.className = 'organelle-box';
    box.dataset.key = org.key;
    box.style.left = cfg.x + 'px';
    box.style.top  = cfg.y + 'px';
    box.style.width  = cfg.w + 'px';
    box.style.height = cfg.h + 'px';
    const rot = (cfg && cfg.r != null) ? (parseFloat(cfg.r) || 0) : 0;
    box.dataset.rot = String(rot);
    box.style.setProperty('--rot', `${rot}deg`);

    const img = document.createElement('img');
    img.alt = org.label;
    img.src = encodeOrgSrc(org.src);
    box.appendChild(img);

    const handle = document.createElement('div');
    handle.className = 'organelle-handle';
    box.appendChild(handle);

    const rhandle = document.createElement('div');
    rhandle.className = 'organelle-rotate-handle';
    rhandle.title = 'Rotate';
    box.appendChild(rhandle);

    layer.appendChild(box);

    attachOrgDragResize(box, handle, rhandle);
  });

  setOrgOpacity(organelleState.opacity ?? 0.18);

  // Preserve selection across reloads; default to the first organelle.
  if(!organelleSelectedKey && ORGANELLES && ORGANELLES.length){
    organelleSelectedKey = ORGANELLES[0].key;
  }
  if(organelleSelectedKey){
    selectOrganelle(organelleSelectedKey);
  }
}

// If older layouts were saved in "world" coords (v1), migrate them to
// screen-space "surface" coords (v2) when we are in surface overlay mode.
function maybeMigrateOrganelleStateToSurface(){
  if(ORGANELLE_COORD_MODE !== 'surface') return;
  if(!organelleState || typeof organelleState !== 'object') return;
  if(organelleState.version === 2) return;
  if(organelleState.version !== 1) return;

  const cy = window.cyGraph;
  const z = (cy && cy.zoom) ? (cy.zoom() || 1) : 1;
  const p = (cy && cy.pan) ? (cy.pan() || {x:0,y:0}) : {x:0,y:0};

  const migrated = {};
  const src = organelleState.organelles || {};
  for(const k of Object.keys(src)){
    const o = src[k] || {};
    const x = (parseFloat(o.x) || 0);
    const y = (parseFloat(o.y) || 0);
    const w = (parseFloat(o.w) || 200);
    const h = (parseFloat(o.h) || 150);
    const r = (parseFloat(o.r) || 0);
    migrated[k] = {
      x: +(x * z + p.x).toFixed(2),
      y: +(y * z + p.y).toFixed(2),
      w: +(w * z).toFixed(2),
      h: +(h * z).toFixed(2),
      r: +r.toFixed(2)
    };
  }

  organelleState = {
    version: 2,
    opacity: organelleState.opacity ?? 0.18,
    organelles: migrated
  };
  localStorage.setItem(ORG_LOCAL_KEY, JSON.stringify(organelleState));
}

// If layouts were saved in screen-space "surface" coords (v2), migrate them to
// Cytoscape model-space "world" coords when we are in world mode.
function maybeMigrateOrganelleStateToWorld(){
  if(ORGANELLE_COORD_MODE !== 'world') return false;
  if(!organelleState || typeof organelleState !== 'object') return false;

  // Detect the stored coordinate mode.
  const storedMode = (typeof organelleState.coordMode === 'string')
    ? organelleState.coordMode
    : ((organelleState.version === 2) ? 'surface' : 'world');

  if(storedMode === 'world') return false;

  const cy = window.cyGraph;
  if(!cy) return false;

  const z = (cy.zoom && cy.zoom()) || 1;
  const p = (cy.pan && cy.pan()) || {x:0,y:0};

  // Inverse of: rendered = model * z + pan
  const migrated = {};
  const src = organelleState.organelles || {};
  for(const k of Object.keys(src)){
    const o = src[k] || {};
    const sx = (parseFloat(o.x) || 0);
    const sy = (parseFloat(o.y) || 0);
    const sw = (parseFloat(o.w) || 200);
    const sh = (parseFloat(o.h) || 150);
    const r  = (parseFloat(o.r) || 0);
    migrated[k] = {
      x: +((sx - p.x) / z).toFixed(2),
      y: +((sy - p.y) / z).toFixed(2),
      w: +(sw / z).toFixed(2),
      h: +(sh / z).toFixed(2),
      r: +r.toFixed(2)
    };
  }

  organelleState = {
    version: 3,
    coordMode: 'world',
    opacity: organelleState.opacity ?? 0.18,
    organelles: migrated
  };
  localStorage.setItem(ORG_LOCAL_KEY, JSON.stringify(organelleState));
  return true;
}
// --- Organelle layer sync: keep DOM background locked to Cytoscape world coordinates ---

function attachOrganelleLayerToCyContainer(){
  const cy = window.cyGraph;
  const layer = document.getElementById('organelle-layer');
  if(!cy || !layer) return;

  const container = cy.container();

  // Ensure our overlay lives INSIDE the Cytoscape container (Safari z-index bug workaround)
  // and is ALWAYS the last child so it paints above internal canvases.
  if(layer.parentElement !== container){
    container.appendChild(layer);
  }
  container.appendChild(layer);

  // Make sure canvases remain underneath within the same stacking context.
  container.querySelectorAll('canvas, svg').forEach(el => {
    el.style.position = 'absolute';
    el.style.inset = '0';
    el.style.zIndex = '1';
  });

  layer.style.position = 'absolute';
  layer.style.inset = '0';
  layer.style.zIndex = '9999';
}




let __orgSyncLast = { z: null, x: null, y: null };
let __orgSyncRAF = null;

function syncOrganelleLayerTransform(force=false){
  const layer = document.getElementById('organelle-layer');
  const cy = window.cyGraph;
  if(!layer) return;

  // Surface mode: keep organelles floating in screen space above the network.
  // No pan/zoom transform should be applied.
  if(ORGANELLE_COORD_MODE === 'surface'){
    if(force || layer.style.transform){
      layer.style.transformOrigin = '0 0';
      layer.style.transform = 'none';
    }
    return;
  }

  if(!cy) return;

  const z = (cy.zoom && cy.zoom()) || 1;
  const p = (cy.pan && cy.pan()) || {x:0, y:0};

  // Cytoscape rendered mapping: rendered = model * z + pan
  // Use a matrix for maximum cross-browser consistency.
  if(!force && __orgSyncLast.z === z && __orgSyncLast.x === p.x && __orgSyncLast.y === p.y) return;
  __orgSyncLast = { z, x: p.x, y: p.y };

  layer.style.transformOrigin = '0 0';
  layer.style.transform = `translate3d(${p.x}px, ${p.y}px, 0px) scale(${z})`;
}

function startOrganelleSyncLoop(){
  if(__orgSyncRAF) return;
  const tick = () => {
    syncOrganelleLayerTransform(false);
    __orgSyncRAF = requestAnimationFrame(tick);
  };
  __orgSyncRAF = requestAnimationFrame(tick);
}

function stopOrganelleSyncLoop(){
  if(!__orgSyncRAF) return;
  cancelAnimationFrame(__orgSyncRAF);
  __orgSyncRAF = null;
}

// Keep the organelle layer glued to Cytoscape pan/zoom so it scales with the network.
function bindOrganelleViewportSync(){
  const cy = window.cyGraph;
  if(!cy) return false;

  // Surface mode: no viewport binding needed. Ensure the layer is identity.
  if(ORGANELLE_COORD_MODE === 'surface'){
    stopOrganelleSyncLoop();
    maybeMigrateOrganelleStateToSurface();
    syncOrganelleLayerTransform(true);
    return true;
  }

  // Initial sync (force) and start a lightweight RAF loop so the background stays
  // in lockstep even if viewport changes happen through animations or internal renders.
  syncOrganelleLayerTransform(true);
  startOrganelleSyncLoop();

  // Also force-sync on explicit viewport/render changes (cheap: we early-return if unchanged).
  cy.on('viewport render resize', () => {
    attachOrganelleLayerToCyContainer();
    syncOrganelleLayerTransform(true);
  });

  return true;
}

function waitForCyThenInitAndBindOrganelles(){
  const tryInit = () => {
    const cy = window.cyGraph;
    if(!cy) return false;

    // Ensure state matches the chosen coord mode BEFORE we render boxes.
    if(ORGANELLE_COORD_MODE === 'world'){
      maybeMigrateOrganelleStateToWorld();
    }else{
      maybeMigrateOrganelleStateToSurface();
    }

    initOrganellesLayer();
    bindOrganelleViewportSync();
    return true;
  };

  if(tryInit()) return;

  let tries = 0;
  const timer = setInterval(() => {
    tries += 1;
    if(tryInit() || tries > 200){
      clearInterval(timer);
    }
  }, 100);
}



function attachOrgDragResize(box, handle, rhandle){
  const key = box.dataset.key;

  let mode = null; // 'drag' | 'resize' | 'rotate'
  let startX=0, startY=0;
  let startLeft=0, startTop=0, startW=0, startH=0;
  let startAngle=0, startRot=0;

  function currentZoom(){
    const cy = window.cyGraph;
    const z = cy ? cy.zoom() : 1;
    return (z && isFinite(z) && z > 0) ? z : 1;
  }

  function coordScale(){
    return (ORGANELLE_COORD_MODE === 'surface') ? 1 : currentZoom();
  }

  function clientToLayer(clientX, clientY){
    const area = document.getElementById('graph-area');
    const rect = area.getBoundingClientRect();
    const rx = clientX - rect.left;
    const ry = clientY - rect.top;

    if(ORGANELLE_COORD_MODE === 'surface'){
      // screen-space overlay: raw pixels relative to the graph area
      return { x: rx, y: ry };
    }

    // world-space: undo Cytoscape pan/zoom
    const cy = window.cyGraph;
    const z = currentZoom();
    const pan = (cy && cy.pan) ? cy.pan() : {x:0, y:0};
    return { x: (rx - pan.x) / z, y: (ry - pan.y) / z };
  }

  function normRotDeg(deg){
    // normalize to [-180, 180) for a stable slider
    let v = deg % 360;
    if(v >= 180) v -= 360;
    if(v < -180) v += 360;
    return v;
  }

  function onPointerDown(e, which){
    if(!organelleEditing) return;
    selectOrganelle(key);

    mode = which;
    box.setPointerCapture(e.pointerId);
    startX = e.clientX;
    startY = e.clientY;

    // Stored in "graph/world" coordinates.
    startLeft = parseFloat(box.style.left)  || 0;
    startTop  = parseFloat(box.style.top)   || 0;
    startW    = parseFloat(box.style.width) || 200;
    startH    = parseFloat(box.style.height)|| 150;

    startRot = parseFloat(box.dataset.rot || '0') || 0;

    if(mode === 'rotate'){
      const center = { x: startLeft + startW/2, y: startTop + startH/2 };
      const pt = clientToLayer(e.clientX, e.clientY);
      startAngle = Math.atan2(pt.y - center.y, pt.x - center.x) * 180 / Math.PI;
    }

    e.preventDefault();
    e.stopPropagation();
  }

  function onPointerMove(e){
    if(!organelleEditing || !mode) return;

    const s = coordScale();
    const dx = (e.clientX - startX) / s;
    const dy = (e.clientY - startY) / s;

    if(mode === 'drag'){
      const left = startLeft + dx;
      const top  = startTop  + dy;
      box.style.left = `${left.toFixed(1)}px`;
      box.style.top  = `${top.toFixed(1)}px`;
    }else if(mode === 'resize'){
      const w = Math.max(40, startW + dx);
      const h = Math.max(40, startH + dy);
      box.style.width  = `${w.toFixed(1)}px`;
      box.style.height = `${h.toFixed(1)}px`;
    }else if(mode === 'rotate'){
      const center = { x: startLeft + startW/2, y: startTop + startH/2 };
      const pt = clientToLayer(e.clientX, e.clientY);
      const ang = Math.atan2(pt.y - center.y, pt.x - center.x) * 180 / Math.PI;
      const delta = ang - startAngle;
      const rot = normRotDeg(startRot + delta);
      box.dataset.rot = String(rot);
      box.style.setProperty('--rot', `${rot}deg`);
      // keep panel slider in sync
      updateOrganellePanelSelection();
    }
  }

  function onPointerUp(e){
    if(!mode) return;
    mode = null;
    try{ box.releasePointerCapture(e.pointerId); }catch(_){}
    persistOrgBoxToState(box);
    scheduleOrganelleAutoSave();
    e.preventDefault();
    e.stopPropagation();
  }

  box.addEventListener('pointerdown', (e) => {
    // Only start drag if not grabbing the resize/rotate handle
    if(e.target === handle || e.target === rhandle) return;
    onPointerDown(e, 'drag');
  });
  handle.addEventListener('pointerdown', (e) => onPointerDown(e, 'resize'));
  rhandle.addEventListener('pointerdown', (e) => onPointerDown(e, 'rotate'));

  box.addEventListener('pointermove', onPointerMove);
  box.addEventListener('pointerup', onPointerUp);
  box.addEventListener('pointercancel', onPointerUp);
}

function persistOrgBoxToState(box){
  const key = box.dataset.key;

  // Persist in the current coordinate mode.
  // - surface: screen pixels relative to #graph-area
  // - world  : model coords (only used if ORGANELLE_COORD_MODE === 'world')
  const x = parseFloat(box.style.left)  || 0;
  const y = parseFloat(box.style.top)   || 0;
  const w = parseFloat(box.style.width) || 200;
  const h = parseFloat(box.style.height)|| 150;

  organelleState.version = (ORGANELLE_COORD_MODE === 'surface') ? 2 : (organelleState.version || 3);
  organelleState.organelles = organelleState.organelles || {};
  organelleState.organelles[key] = {
    x: +x.toFixed(2),
    y: +y.toFixed(2),
    w: +w.toFixed(2),
    h: +h.toFixed(2),
    r: +( (parseFloat(box.dataset.rot || '0') || 0).toFixed(2) )
  };
  localStorage.setItem(ORG_LOCAL_KEY, JSON.stringify(organelleState));
}

function persistAllOrganelleBoxes(){
  const layer = document.getElementById('organelle-layer');
  layer.querySelectorAll('.organelle-box').forEach(box => persistOrgBoxToState(box));
}

let orgSaveTimer = null;
function scheduleOrganelleAutoSave(){
  if(orgSaveTimer) clearTimeout(orgSaveTimer);
  orgSaveTimer = setTimeout(() => {
    try{
      persistAllOrganelleBoxes();
    }catch(e){}
  }, 250);
}

async function saveOrganellesToServer(){
  persistAllOrganelleBoxes();
  const payload = {
    version: organelleState.version || organelleVersionForMode(),
    coordMode: ORGANELLE_COORD_MODE,
    opacity: organelleState.opacity ?? 0.18,
    organelles: organelleState.organelles || {}
  };
  try{
    const r = await fetch('/api/organelles', {
      method:'POST',
      headers:{ 'Content-Type':'application/json' },
      body: JSON.stringify(payload)
    });
    if(r.ok){
      showStatus('Organelles saved âœ…', false);
    }else{
      showStatus('Organelles save failed.', true);
    }
  }catch(e){
    showStatus('Organelles save failed.', true);
  }
}

async function resetOrganelles(){
  organelleState = { version: organelleVersionForMode(), coordMode: ORGANELLE_COORD_MODE, opacity: 0.18, organelles: {} };
  localStorage.setItem(ORG_LOCAL_KEY, JSON.stringify(organelleState));
  initOrganellesLayer();
  try{
    await fetch('/api/organelles', { method:'DELETE' });
  }catch(e){}
  showStatus('Organelles reset.', false);
}

function setOrganelleEditing(on){
  organelleEditing = on;
  const layer = document.getElementById('organelle-layer');
  const panel = document.getElementById('organelle-panel');
  const opacityInput = document.getElementById('organelle-opacity');
  const opacityVal = document.getElementById('organelle-opacity-val');

  const cy = window.cyGraph || null;

  if(on){
    layer.classList.add('editing');
    panel.style.display = 'block';
    // Put the layer above cy so you can grab and resize
    layer.querySelectorAll('.organelle-box').forEach(b => b.classList.add('editing'));
    if(!organelleSelectedKey && ORGANELLES && ORGANELLES.length){ organelleSelectedKey = ORGANELLES[0].key; }
    if(organelleSelectedKey){ selectOrganelle(organelleSelectedKey); }

    // Temporarily disable cy interactions to avoid accidental drags
    if(cy){
      cy.userPanningEnabled(false);
      cy.userZoomingEnabled(false);
      cy.boxSelectionEnabled(false);
    }
  }else{
    layer.classList.remove('editing');
    panel.style.display = 'none';
    layer.querySelectorAll('.organelle-box').forEach(b => b.classList.remove('editing'));
    // Sink below the network again
    if(cy){
      cy.userPanningEnabled(true);
      cy.userZoomingEnabled(true);
      cy.boxSelectionEnabled(true);
    }
  }

  const alpha = organelleState.opacity ?? 0.18;
  opacityInput.value = Math.round(alpha*100);
  opacityVal.textContent = Math.round(alpha*100) + '%';
  setOrgOpacity(alpha);

  // Make sure the layer transform is in sync (especially after toggling modes)
  syncOrganelleLayerTransform();
}

function bindOrganelleUI(){
  const toggleBtn = document.getElementById('organelle-toggle-btn');
  const doneBtn = document.getElementById('organelle-done-btn');
  const saveBtn = document.getElementById('organelle-save-btn');
  const resetBtn= document.getElementById('organelle-reset-btn');
  const opacityInput = document.getElementById('organelle-opacity');
  const opacityVal = document.getElementById('organelle-opacity-val');

  toggleBtn.addEventListener('click', () => setOrganelleEditing(!organelleEditing));
  doneBtn.addEventListener('click', () => setOrganelleEditing(false));
  saveBtn.addEventListener('click', () => saveOrganellesToServer());
  resetBtn.addEventListener('click', () => resetOrganelles());

  opacityInput.addEventListener('input', (e) => {
    const v = parseInt(e.target.value, 10) || 0;
    const alpha = Math.max(0, Math.min(1, v/100));
    organelleState.opacity = alpha;
    opacityVal.textContent = v + '%';
    setOrgOpacity(alpha);
    localStorage.setItem(ORG_LOCAL_KEY, JSON.stringify(organelleState));
    scheduleOrganelleAutoSave();
  });

  // Rotation (per selected organelle)
  const rotInput = document.getElementById('organelle-rotate');
  const rotVal = document.getElementById('organelle-rotate-val');

  rotInput.addEventListener('input', (e) => {
    if(!organelleSelectedKey) return;
    const deg = parseInt(e.target.value, 10) || 0;
    rotVal.textContent = deg + 'Â°';

    const box = getOrgBoxEl(organelleSelectedKey);
    if(box){
      box.dataset.rot = String(deg);
      box.style.setProperty('--rot', `${deg}deg`);
      persistOrgBoxToState(box);
      scheduleOrganelleAutoSave();
    }else{
      // still persist in state (e.g., before boxes render)
      organelleState.organelles = organelleState.organelles || {};
      const prev = organelleState.organelles[organelleSelectedKey] || {};
      organelleState.organelles[organelleSelectedKey] = { ...prev, r: deg };
      localStorage.setItem(ORG_LOCAL_KEY, JSON.stringify(organelleState));
    }
  });

  // Keep panel in sync on first load
  updateOrganellePanelSelection();
}



// Hook into the existing app start
(async function bootOrganelles(){
  await loadOrganellesState();
  bindOrganelleUI();

  // Wait for Cytoscape to exist, then migrate coordinates (if needed), render boxes,
  // and bind pan/zoom sync so organelles move/scale exactly like nodes.
  let tries = 0;
  const timer = setInterval(() => {
    tries += 1;
    if(window.cyGraph){
      clearInterval(timer);
      attachOrganelleLayerToCyContainer();

      // Handle cross-mode migrations using the live viewport.
      if(ORGANELLE_COORD_MODE === 'world'){
        maybeMigrateOrganelleStateToWorld();
      }else{
        maybeMigrateOrganelleStateToSurface();
      }

      initOrganellesLayer();
      bindOrganelleViewportSync();
    }
    if(tries > 200){ clearInterval(timer); }
  }, 100);
})();

</script> </body> </html>