<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metabolic Pathway</title>
    
    <style>
        /* === å…¨å±€æ ·å¼ === */
        body {
            font-family: "Microsoft YaHei", "Segoe UI", sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background-color: #f8f9fa;
        }

        /* === é¡¶éƒ¨å¯¼èˆªæ  === */
        header {
            background-color: #fff;
            padding: 15px 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            display: flex;
            align-items: center;
            gap: 20px;
            z-index: 10;
        }
        h1 { margin: 0; font-size: 18px; color: #333; }
        
         /* åœ¨ <style> ä¸­ */
    #search-sidebar {
    width: 1000px;
    background: #fff;
    border-left: 1px solid #ddd;
    padding: 20px;
    overflow-y: auto;
    /* åˆ é™¤ display: flex; è¿™ä¸€è¡Œï¼Œè®©å®ƒé»˜è®¤éµå¾ª HTML é‡Œçš„ style="display:none" */
    /* æˆ–è€…ä¿ç•™ display: flex ä½†ä¾èµ– JS è¦†ç›– inline styleï¼Œé€šå¸¸æ²¡é—®é¢˜ï¼Œä½†åˆ é™¤æ›´ä¿é™© */
    flex-direction: column;
    box-shadow: -2px 0 5px rgba(0,0,0,0.05);
    transition: all 0.3s ease;

    }

        /* å•ä¸ªæœç´¢ç»“æœå¡ç‰‡ */
        .result-item {
            padding: 10px;
            margin-bottom: 8px;
            background: #fff;
            border: 1px solid #eee;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .result-item:hover {
            background-color: #f0f7ff;
            border-color: #2196F3;
            transform: translateX(-3px); /* æ‚¬åœæ—¶å¾®åŠ¨æ•ˆæœ */
            box-shadow: 2px 2px 5px rgba(0,0,0,0.05);
        }

        .result-name {
            font-size: 14px;
            font-weight: bold;
            color: #333;
            margin-bottom: 4px;
        }

        .result-pathway {
            font-size: 11px;
            color: #666;
            background: #f1f2f6;
            padding: 2px 6px;
            border-radius: 4px;
            display: inline-block;
        }
        
        .result-type-tag {
            font-size: 10px;
            padding: 2px 4px;
            border-radius: 3px;
            margin-left: 5px;
            color: #fff;
        }

        /* æ§åˆ¶æ§ä»¶ */
        .controls { display: flex; align-items: center; gap: 10px; }
        .status { font-size: 12px; color: #666; }
        
        /* é”™è¯¯æç¤º */
        #error-msg {
            color: #d32f2f;
            background: #ffebee;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            display: none;
        }

        /* === å†…å®¹åŒºåŸŸ === */
        #main-container {
            flex: 1;
            display: flex;
            overflow: hidden; /* é˜²æ­¢åŒæ»šåŠ¨æ¡ */
        }

        /* å·¦ä¾§ä¾§è¾¹æ ï¼šç­›é€‰å™¨ */
        #sidebar {
            width: 260px;
            background: #fff;
            border-right: 1px solid #eee;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        .sidebar-title {
            font-size: 14px; font-weight: bold; color: #555;
            margin-bottom: 15px; text-transform: uppercase; letter-spacing: 1px;
        }
        
        /* Pathway å¤é€‰æ¡† */
        .pathway-list { display: flex; flex-direction: column; gap: 8px; }
        .checkbox-item {
            display: flex; align-items: center;
            cursor: pointer; font-size: 13px; color: #444;
            padding: 5px; border-radius: 4px; transition: background 0.2s;
        }
        .checkbox-item:hover { background: #f0f7ff; }
        
        .side-action-btn{
            margin: 6px 0 10px 0;
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: #fff;
            cursor: pointer;
            font-size: 12px;
            color: #444;
        }
        .side-action-btn:hover{ background: #f6f6f6; }

        .pw-text{ flex: 1; margin-left: 6px; }
        .side-toggle-btn{
            margin-left: 8px;
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 999px;
            background: #fff;
            cursor: pointer;
            font-size: 11px;
            color: #444;
            white-space: nowrap;
        }
        .side-toggle-btn:hover{ background: #f6f6f6; }
        .side-toggle-btn.active{
            background: #efefef;
            font-weight: 600;
        }
.checkbox-item input { margin-right: 10px; accent-color: #2196F3; }

        /* åˆ†ç»„ Pathway åˆ—è¡¨ */
        .sheet-group { margin-top: 12px; padding-top: 8px; border-top: 1px solid #eee; }
        .sheet-header { display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom: 6px; }
        .sheet-name { display:flex; align-items:center; gap:6px; font-size: 12px; font-weight: bold; color:#333; }
        .sheet-swatch { width:10px; height:10px; border-radius: 3px; }
        .sheet-selectall { font-size: 12px; margin: 0; padding: 0; }
        .sheet-body { display:flex; flex-direction:column; gap:6px; margin-left: 10px; }

        /* å³ä¾§ç»˜å›¾åŒº */
        #graph-area {
            flex: 1;
            position: relative;
            background: #f8f9fa;
        }
        #cy { width: 100%; height: 100%; }

        /* åŠ è½½é®ç½© */
        #loading {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255,255,255,0.8);
            display: flex; justify-content: center; align-items: center;
            font-size: 16px; color: #666;
            z-index: 20;
        }
    </style>
</head>
<body>
    <!-- 1. åŠ è½½é®ç½©å±‚ -->
    <div id="loading-mask" style="position: fixed; top:0; left:0; width:100%; height:100%; background: rgba(255,255,255,0.95); z-index: 9999; display: flex; flex-direction: column; justify-content: center; align-items: center;">
        <h2 style="color: #333;">Loading...</h2>
        <div style="width: 300px; height: 10px; background: #eee; border-radius: 5px; overflow: hidden; margin-top: 10px;">
            <div id="progress-bar" style="width: 0%; height: 100%; background: #0984e3; transition: width 0.1s;"></div>
        </div>
        <p id="progress-text" style="margin-top: 10px; color: #666; font-size: 14px;">å‡†å¤‡æ•°æ®ä¸­...</p>
    </div>

    <!-- 2. é¡¶éƒ¨å¯¼èˆªæ  -->
    <header>
        <h1>ğŸŒ± Metabolic Pathway</h1>
        
        <!-- æœç´¢æ¡† -->
        <div class="search-container" style="display:flex; align-items:center; gap:5px;">
            <label for="search-input">ğŸ”</label>
            <input type="text" id="search-input" placeholder="è¾“å…¥åç§° (å¦‚ ATP)..." style="padding: 5px; width: 180px; border:1px solid #ccc; border-radius:4px;">
            <span id="search-status" style="color: #666; font-size: 12px; margin-left:5px;"></span>
        </div>

        <!-- å¸ƒå±€æ§åˆ¶æŒ‰é’® -->
        <div class="controls" style="margin-left: auto;">
            <button onclick="saveLayout()" style="cursor:pointer; padding:5px 10px; border:1px solid #ccc; background:#fff; border-radius:4px;">ğŸ’¾ ä¿å­˜å¸ƒå±€</button>
            <button onclick="clearLayoutCache()" style="cursor:pointer; padding:5px 10px; border:1px solid #ccc; background:#fff; border-radius:4px;">ğŸ”„ é‡ç½®</button>
            <span id="status" class="status"></span>
        </div>
        <div id="error-msg"></div>
    </header>

    <!-- 3. ä¸»å†…å®¹åŒºåŸŸ (æ ¸å¿ƒä¿®æ”¹ï¼šç¡®ä¿åªæœ‰ä¸€ä¸ª clean çš„ container) -->
    <div id="main-container">
        
        <!-- å·¦ä¾§ï¼šç­›é€‰æ§åˆ¶ -->
        <div id="sidebar">
            <div class="sidebar-title">Pathway Select</div>
            <div id="filter-container" class="pathway-list">
                <div style="color:#999; font-style:italic;">æš‚æ— æ•°æ®</div>
            </div>
            
            <div style="margin-top:20px; font-size:10px; color:#999; line-height:1.5;">
                <hr style="border:0; border-top:1px solid #eee; margin:10px 0;">
                <p>ğŸ’¡ <b>å›¾ä¾‹è¯´æ˜ï¼š</b></p>
                <p><span style="color:#2ecc71">â—</span>  Main Sunstrate</p>
                <p><span style="color:#74b9ff">â—</span>  Other Reactant</p>
                <p><span style="color:#a29bfe">â—</span>  Other Product</p>
                <p><span style="border:1px solid #55efc4; border-radius:50%; display:inline-block; width:8px; height:8px;"></span> ç©ºå¿ƒ: é…¶/ååº”èŠ‚ç‚¹</p>
            </div>
        </div>

        <!-- ä¸­é—´ï¼šCytoscape ç”»å¸ƒ -->
        <div id="graph-area">
            <div id="loading" style="display:none;">å¤„ç†ä¸­...</div>
            <div id="cy"></div>
        </div>

        <!-- å³ä¾§ï¼šæœç´¢ç»“æœæ  (é»˜è®¤éšè—) -->
        <div id="search-sidebar" style="display: none;">
            <div class="sidebar-title" style="display:flex; justify-content:space-between; align-items:center;">
                <span>æœç´¢ç»“æœ (<span id="result-count">0</span>)</span>
                <!-- å…³é—­æŒ‰é’® -->
                <button onclick="closeSearchPanel()" style="border:none; background:none; cursor:pointer; font-size:18px; color:#999;">&times;</button>
            </div>
            <div id="search-results-list" class="pathway-list">
                <!-- JS ä¼šåœ¨è¿™é‡Œæ’å…¥ .result-item -->
            </div>
        </div>

    </div>

    


    <!-- è„šæœ¬åº“ (Staticfile CDN) -->
    <script src="https://cdn.staticfile.org/cytoscape/3.23.0/cytoscape.min.js"></script>
    <script src="https://cdn.staticfile.org/dagre/0.8.5/dagre.min.js"></script>
    <script src="https://unpkg.com/cytoscape-dagre@2.4.0/cytoscape-dagre.js"></script>

<script>
    // ================= é…ç½®åŒºåŸŸ =================
    // åœ¨æ­¤å¤„è¾“å…¥ä½ æƒ³åˆå¹¶æ˜¾ç¤ºçš„ Sheet åç§°
    const TARGET_SHEETS = ["Carbonhydrates", "Lipids", "Proteins", "Nucleotides"];

    // ä¸»é¢˜è‰²ï¼šä¸åŒ sheet çš„ä¸»ååº”ç‰©/ä¸»äº§ç‰©
    const SHEET_COLORS = {
        Carbonhydrates: "#E699A7",
        Lipids: "#FEDD9E",
        Proteins: "#A6D9C0",
        Nucleotides: "#71A7D2"
    };
    // é¢œè‰²ä¼˜å…ˆçº§ï¼šè‹¥åŒä¸€åˆ†å­å‡ºç°åœ¨å¤šä¸ª sheetsï¼ŒæŒ‰æ­¤é¡ºåºå–è‰²
    const SHEET_PRIORITY = ["Carbonhydrates", "Lipids", "Proteins", "Nucleotides"];

    // ====== Side-molecule visibility state ======
    // é€‰ä¸­çš„â€œé…¶/ååº”â€é›†åˆï¼šç‚¹é€‰å¤šä¸ªååº”æ—¶ï¼Œå°åˆ†å­ä¸ä¼šæ¶ˆå¤±
    window.selectedReactionIds = new Set();
    // è¢«â€œDemonstrate currencyâ€æŒ‰é’®å›ºå®šæ‰“å¼€çš„å°åˆ†å­ï¼šæŒ‰ pathway ç»´åº¦
    window.pinnedSidePathways = new Set();
    // å½“å‰ pathway å‹¾é€‰çŠ¶æ€ï¼ˆç”¨äº side-molecule çš„æ˜¾ç¤ºè£å‰ªï¼‰
    window.__selectedPathwaysSet = new Set();


    function pickSheetColor(sheetSet) {
        if (!sheetSet) return "#95a5a6";
        for (const s of SHEET_PRIORITY) {
            if (sheetSet.has(s)) return SHEET_COLORS[s];
        }
        return "#95a5a6";
    }

// ===========================================

    // å®šä¹‰ä¸€ä¸ª Keyï¼Œç”¨äºåœ¨æµè§ˆå™¨ç¼“å­˜ä¸­å­˜å‚¨æ•°æ®
    const STORAGE_KEY = 'metabolic_pathway_positions_v1';

    // ============================================================
    // Layout file persistence via backend (/api/layout)
    // - Save positions to layout_positions.json on the server
    // - Load them on startup and hydrate localStorage autosave cache
    // ============================================================
    async function saveLayoutToServer(positions) {
        try {
            await fetch('/api/layout', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ positions })
            });
        } catch (e) {
            // ignore: keep UI responsive even if server write fails
            console.warn('[layout] save to server failed:', e.message || e);
        }
    }

    async function preloadLayoutFromServer() {
        try {
            const res = await fetch('/api/layout', { method: 'GET' });
            if (!res.ok) return false;
            const positions = await res.json();
            if (!positions || typeof positions !== 'object') return false;

            // Put into autosave cache so existing restoreLayoutAuto() works unchanged
            const autoKey = STORAGE_KEY + '_autosave';
            localStorage.setItem(autoKey, JSON.stringify(positions));
            return true;
        } catch (e) {
            console.warn('[layout] preload from server failed:', e.message || e);
            return false;
        }
    }

    async function clearLayoutOnServer() {
        try {
            await fetch('/api/layout', { method: 'DELETE' });
        } catch (e) {
            console.warn('[layout] clear on server failed:', e.message || e);
        }
    }


    // ============================================
    // 1. ä¿å­˜å¸ƒå±€å‡½æ•°
    // ============================================
    function saveLayout() {
        if (!window.cyGraph) return;

        const positions = {};
        // éå†æ‰€æœ‰èŠ‚ç‚¹ï¼Œè®°å½• ID å’Œ (x, y) åæ ‡
        window.cyGraph.nodes().forEach(node => {
            positions[node.id()] = node.position();
        });

        // è½¬æˆ JSON å­—ç¬¦ä¸²å­˜å…¥ LocalStorage
        localStorage.setItem(STORAGE_KEY, JSON.stringify(positions));
        
        
        // åŒæ­¥ä¿å­˜åˆ°æœåŠ¡å™¨æ–‡ä»¶ layout_positions.json
        saveLayoutToServer(positions);
alert(`å·²ä¿å­˜ ${Object.keys(positions).length} ä¸ªèŠ‚ç‚¹çš„ä½ç½®ï¼\nä¸‹æ¬¡åˆ·æ–°é¡µé¢å°†ä¿æŒæ­¤å¸ƒå±€ã€‚`);
    }

    // ============================================
    // 2. æ¸…é™¤å¸ƒå±€(é‡ç½®)å‡½æ•°
    // ============================================
    function clearLayoutCache() {
        localStorage.removeItem(STORAGE_KEY);
                localStorage.removeItem(STORAGE_KEY + '_autosave');
        clearLayoutOnServer();
alert('å·²æ¸…é™¤å¸ƒå±€ç¼“å­˜ã€‚åˆ·æ–°é¡µé¢å°†é‡æ–°è®¡ç®—é»˜è®¤å¸ƒå±€ã€‚');
        location.reload(); // è‡ªåŠ¨åˆ·æ–°é¡µé¢
    }




    let cy = null;

        // ============================================================
    // æœç´¢åŠŸèƒ½æ¨¡å—
    // ============================================================
    function initSearchListener() {
        const searchInput = document.getElementById('search-input');
        if(!searchInput) return;

        // ç›‘å¬è¾“å…¥äº‹ä»¶ (input ä»£è¡¨æ¯æ¬¡æ‰“å­—éƒ½è§¦å‘)
        searchInput.addEventListener('input', function(e) {
            const term = e.target.value.trim().toLowerCase();
            performSearch(term);
        });
    }

        // ===================================
    // æœç´¢é€»è¾‘æ›´æ–° (æ”¯æŒå³ä¾§æ æ˜¾ç¤º + ç‚¹å‡»å®šä½)
    // ===================================
    function performSearch(term) {
        const cy = window.cyGraph;
        if (!cy) return;
        
        const statusSpan = document.getElementById('search-status');
        const sidebar = document.getElementById('search-sidebar');

        // 1. å¦‚æœæœç´¢æ¡†æ¸…ç©º
        if (!term) {
            filterGraph(); // æ¢å¤ç­›é€‰çŠ¶æ€
            statusSpan.innerText = "";
            sidebar.style.display = 'none'; // éšè—å³ä¾§æ 
            return;
        }

        // 2. æ‰§è¡Œæœç´¢
        cy.batch(() => {
            cy.elements().removeClass('highlighted').addClass('dimmed');

            const matchedNodes = cy.nodes().filter(node => {
                const label = node.data('label');
                return label && String(label).toLowerCase().includes(term);
            });

            if (matchedNodes.length === 0) {
                statusSpan.innerText = "æœªæ‰¾åˆ°åŒ¹é…èŠ‚ç‚¹";
                sidebar.style.display = 'none';
                return;
            }

            // é«˜äº®
            matchedNodes.removeClass('dimmed').addClass('highlighted');
            matchedNodes.neighborhood().removeClass('dimmed').addClass('highlighted');

            // æ›´æ–°é¡¶éƒ¨æ–‡å­—
            statusSpan.innerText = `æ‰¾åˆ° ${matchedNodes.length} ä¸ªç»“æœ`;

            // 3. ã€æ ¸å¿ƒã€‘æ¸²æŸ“å³ä¾§ç»“æœåˆ—è¡¨
            renderSearchResults(matchedNodes);
        });
    }

    // æ¸²æŸ“å³ä¾§åˆ—è¡¨çš„å‡½æ•°
    function renderSearchResults(nodes) {
        const sidebar = document.getElementById('search-sidebar');
        const listContainer = document.getElementById('search-results-list');
        const countSpan = document.getElementById('result-count');

        // æ˜¾ç¤ºä¾§è¾¹æ 
        sidebar.style.display = 'flex';
        listContainer.innerHTML = ''; // æ¸…ç©ºæ—§ç»“æœ
        countSpan.innerText = nodes.length;

        nodes.forEach(node => {
            const data = node.data();
            
            // åˆ›å»ºå¡ç‰‡ DOM
            const item = document.createElement('div');
            item.className = 'result-item';
            
            // åˆ¤æ–­ç±»å‹æ ‡ç­¾é¢œè‰²
            let typeColor = '#95a5a6';
            let typeText = 'Unknown';
            if(node.hasClass('reaction')) { typeColor = '#55efc4'; typeText = 'é…¶/ååº”'; }
            else if(node.hasClass('main-molecule')) { typeColor = '#2ecc71'; typeText = 'Main Substrate'; }
            else { typeColor = '#74b9ff'; typeText = 'Other Substrate'; }

            item.innerHTML = `
                <div class="result-name">
                    ${data.label || data.id}
                    <span class="result-type-tag" style="background:${typeColor}">${typeText}</span>
                </div>
                <div class="result-pathway">ğŸ“‚ ${data.pathway || 'æœªåˆ†ç±»'}</div>
            `;

            // ç‚¹å‡»äº‹ä»¶ï¼šç§»åŠ¨è§†è§’
            item.addEventListener('click', () => {
                // 1. åœ¨å›¾ä¸Šåªé«˜äº®è¿™ä¸€ä¸ª (å¯é€‰ï¼Œè¿™æ­¥è®©ç”¨æˆ·æ›´èšç„¦)
                window.cyGraph.elements().removeClass('highlighted').addClass('dimmed');
                node.removeClass('dimmed').addClass('highlighted');
                node.neighborhood().removeClass('dimmed').addClass('highlighted');

                // 2. åŠ¨ç”»ç§»åŠ¨
                window.cyGraph.animate({
                    fit: {
                        eles: node,
                        padding: 150 // paddingå¤§ä¸€ç‚¹ï¼Œåˆ«è´´å¤ªæ­»
                    },
                    duration: 500,
                    easing: 'ease-out-cubic'
                });

                // 3. UIåé¦ˆï¼šç»™å½“å‰ç‚¹å‡»çš„åˆ—è¡¨é¡¹åŠ ä¸ªæ·±è‰²èƒŒæ™¯æ ‡è®°
                document.querySelectorAll('.result-item').forEach(d => d.style.borderColor = '#eee');
                item.style.borderColor = '#2196F3';
            });

            listContainer.appendChild(item);
        });
    }

    // å…³é—­å³ä¾§æ 
    function closeSearchPanel() {
        document.getElementById('search-sidebar').style.display = 'none';
        document.getElementById('search-input').value = ''; // æ¸…ç©ºè¾“å…¥æ¡†
        filterGraph(); // æ¢å¤è§†å›¾
        document.getElementById('search-status').innerText = '';
    }

    // é¡µé¢åŠ è½½å®Œæˆåæ‰§è¡Œ
    window.onload = async function() {
        try {
            if (typeof cytoscapeDagre !== 'undefined') {
                cytoscape.use(cytoscapeDagre);
            }
        } catch (e) { console.warn("Layout plugin already registered"); }

        await loadAndMergeSheets();
    };

    async function loadAndMergeSheets() {
        document.getElementById('loading').style.display = 'flex';
        updateStatus(`æ­£åœ¨åˆå¹¶åŠ è½½: ${TARGET_SHEETS.join(', ')}...`);

        try {
            let combinedData = [];
            const requests = TARGET_SHEETS.map(name =>
                fetch(`/api/data/${encodeURIComponent(name)}`)
                    .then(res => {
                        if(!res.ok) throw new Error(`Sheet [${name}] ä¸å­˜åœ¨æˆ–è¯»å–å¤±è´¥`);
                        return res.json();
                    })
                    .then(sheetData => {
                        // ç»™æ¯ä¸€è¡ŒåŠ ä¸Šæ¥æº sheet æ ‡ç­¾ï¼Œä¾¿äºåˆ†ç»„ä¸é…è‰²
                        sheetData.forEach(row => row.__sheet = name);
                        return sheetData;
                    })
            );

            const results = await Promise.all(requests);
            results.forEach(sheetData => {
                combinedData = combinedData.concat(sheetData);
            });


            console.log(`åˆå¹¶å®Œæˆï¼Œå…± ${combinedData.length} è¡Œæ•°æ®`);
                        // é¢„åŠ è½½ä¸Šä¸€æ¬¡ä¿å­˜çš„å¸ƒå±€åæ ‡ï¼ˆæœåŠ¡å™¨æ–‡ä»¶ï¼‰
            await preloadLayoutFromServer();

            processDataAndDraw(combinedData);

        } catch (err) {
            console.error(err);
            showError(`åˆå¹¶åŠ è½½å¤±è´¥: ${err.message}`);
        } finally {
            document.getElementById('loading').style.display = 'none';
        }
    }

        // ============================================================
    // 1. æ•°æ®å¤„ç† (Process Data) - ä¿®æ”¹ç‰ˆï¼šå‰¯äº§ç‰©ä¸åˆå¹¶
    // ============================================================
        // ============================================================
    // 1. æ•°æ®å¤„ç† (Process Data) - å·²ä¿®æ”¹æ”¯æŒé…è‰²åŒºåˆ†
    // ============================================================
    function processDataAndDraw(data) {
        const elements = [];
        const pathwaySet = new Set();

        // --- å·¦ä¾§æ åˆ†ç»„ï¼šæŒ‰ sheet è®°å½• Pathway å‡ºç°é¡ºåºï¼ˆä¿æŒ Excel ä¸­çš„é¡ºåºï¼‰ ---
        const pathwaysBySheet = new Map();
        const pathwaySeenBySheet = new Map();
        TARGET_SHEETS.forEach(s => {
            pathwaysBySheet.set(s, []);
            pathwaySeenBySheet.set(s, new Set());
        });

        const addedMainNodes = new Set();

        // --- ä¸»å¹²åˆ†å­å…ƒä¿¡æ¯ï¼šç”¨äºå¤š-sheet å–è‰² & é€‰ä¸­ Pathway æ—¶ä¸´æ—¶æ”¹è‰² ---
        // Map<nodeId, { sheets:Set<string>, pathwaySheets: Map<pathway, Set<sheet>> }>
        const mainMoleculeMeta = new Map();
        window.mainMoleculeMeta = mainMoleculeMeta;

        // 1. ä¸»å¹²èŠ‚ç‚¹ (ä¸»è¦ååº”ç‰©/äº§ç‰©) -> é¢œè‰²ç”± sheet å†³å®šï¼ˆdata.colorï¼‰
                // 1. ä¸»å¹²èŠ‚ç‚¹ (ä¸»è¦ååº”ç‰©/äº§ç‰©) -> é¢œè‰²ç”± sheet å†³å®šï¼ˆdata.colorï¼‰
        // è¯´æ˜ï¼šåŒååˆ†å­åœ¨ä¸åŒç»†èƒå™¨(Place in Cell)ä¼šç”Ÿæˆä¸åŒèŠ‚ç‚¹ï¼Œç”¨äºé¿å…é‡åˆï¼Œå¹¶é¢å¤–ç”Ÿæˆâ€œè½¬è¿(transport)â€è¿æ¥
        const moleculeCompNodes = new Map(); // Map<baseName, Array<nodeId>>
        const addMainNode = (baseName, compKey, sheetName, pathwayName) => {
            if (!baseName) return;

            const nodeId = makeCompartmentNodeId(baseName, compKey);

            // metaMap æŒ‰â€œåˆ†å­åŸºåâ€èšåˆï¼šç”¨äºå¤š-sheet å–è‰²
            if (!mainMoleculeMeta.has(baseName)) {
                mainMoleculeMeta.set(baseName, { sheets: new Set(), pathwaySheets: new Map() });
            }
            const meta = mainMoleculeMeta.get(baseName);
            if (sheetName) meta.sheets.add(sheetName);

            if (pathwayName) {
                if (!meta.pathwaySheets.has(pathwayName)) meta.pathwaySheets.set(pathwayName, new Set());
                if (sheetName) meta.pathwaySheets.get(pathwayName).add(sheetName);
            }

            // è®°å½•â€œåŒååˆ†å­â€çš„ä¸åŒç»†èƒå™¨èŠ‚ç‚¹ï¼Œç”¨äºåç»­è½¬è¿è¿çº¿
            if (!moleculeCompNodes.has(baseName)) moleculeCompNodes.set(baseName, []);
            if (!moleculeCompNodes.get(baseName).includes(nodeId)) moleculeCompNodes.get(baseName).push(nodeId);

            if (!addedMainNodes.has(nodeId)) {
                elements.push({
                    data: {
                        id: nodeId,
                        label: baseName,          // å±•ç¤ºåä¿æŒä¸€è‡´
                        baseName: baseName,       // ç”¨äºå–è‰²/èšåˆ
                        compartment: compKey || '',
                        type: 'molecule',
                        color: '#2ecc71'          // color åç»­ç»Ÿä¸€å›å¡«
                    },
                    classes: 'main-molecule'
                });
                addedMainNodes.add(nodeId);
            }
        };


const addSideNode = (newId, labelName, extraClass, parentRxn, role, pathway, sheet) => {
            elements.push({
                data: {
                    id: newId,
                    label: labelName,
                    type: 'molecule',
                    parentRxn: parentRxn || '',
                    role: role || '',
                    pathway: pathway || '',
                    sheet: sheet || ''
                },
                // é»˜è®¤éšè—å‰¯å°åˆ†å­ï¼Œåªæœ‰é€‰ä¸­ååº”æˆ–ç‚¹å‡» pathway æŒ‰é’®æ‰æ˜¾ç¤º
                classes: `side-molecule ${extraClass} hidden-side`
            });
        };

        const parseMolecules = (str) => {
            if (!str) return [];
            return String(str).split(';').map(s => s.split(':')[0].trim()).filter(s => s);
        };
        // Place in Cell: ä½œä¸ºç»†èƒå™¨æ ‡ç­¾ï¼Œç”¨æ¥åŒºåˆ†åŒååˆ†å­åœ¨ä¸åŒç»†èƒå™¨ä¸­çš„å®ä¾‹
        const normalizeCompartment = (place) => {
            if (!place) return '';
            const raw = String(place).trim();
            if (!raw || raw === '0') return '';
            // å–ç¬¬ä¸€ä¸ªæ ‡ç­¾ï¼ˆè‹¥æœ‰å¤šä¸ªç”¨ ; æˆ– , åˆ†éš”ï¼‰
            const first = raw.split(/[;,]/)[0].trim();
            // ç”¨äº node id çš„å®‰å…¨ç‰ˆæœ¬
            return first.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '_');
        };

        const makeCompartmentNodeId = (baseName, compKey) => {
            if (!compKey) return baseName;
            return `${baseName}@@${compKey}`;
        };


        data.forEach((row, index) => {
            const mainSources = parseMolecules(row['Main Reactant']);
            const sideSources = parseMolecules(row['Other Reactant']); 
            const mainTargets = parseMolecules(row['Main Product']);
            const sideTargets = parseMolecules(row['Other Product']); 

            if (mainSources.length + sideSources.length > 0 && mainTargets.length + sideTargets.length > 0) {
                const pathway = row['Pathway'];
                const enzyme = row['Enzyme'];
                const sheetName = row.__sheet || 'Unknown';
                const compKey = normalizeCompartment(row['Place in Cell']);

                if (pathway) {
                    pathwaySet.add(pathway);

                    if (!pathwaysBySheet.has(sheetName)) {
                        pathwaysBySheet.set(sheetName, []);
                        pathwaySeenBySheet.set(sheetName, new Set());
                    }
                    const seen = pathwaySeenBySheet.get(sheetName);
                    if (!seen.has(pathway)) {
                        pathwaysBySheet.get(sheetName).push(pathway);
                        seen.add(pathway);
                    }
                }
const rxnId = `rxn_${index}`;
                // ç®€å•çš„åˆ¤æ–­æ˜¾ç¤º Label
                const isZeroEnzyme = !enzyme || String(enzyme).trim() === '0' || String(enzyme).trim() === '';
                const labelText = isZeroEnzyme ? '' : enzyme;
                
                // ååº”èŠ‚ç‚¹
                elements.push({
                    data: { 
                        id: rxnId, 
                        label: labelText, 
                        type: 'reaction', // ç”¨äºè¯†åˆ«é…¶èŠ‚ç‚¹
                        pathway: pathway || 'Uncategorized'
                    },
                    classes: 'reaction' // ç»Ÿä¸€ååº”èŠ‚ç‚¹ç±»å
                });

                // --- å¤„ç†å…¥è¾¹ (Input) ---

                // Main Sources
                mainSources.forEach(sourceName => {
                    const srcId = makeCompartmentNodeId(sourceName, compKey);
                    addMainNode(sourceName, compKey, sheetName, pathway);
                    elements.push({
                        data: { 
                            source: srcId, target: rxnId, 
                            pathway: pathway, type: 'in', edgeType: 'main' // type='in'
                        },
                        classes: 'edge-main'
                    });
                });

                // Side Sources (å‰¯ååº”ç‰©) -> æµ…è“è‰²
                sideSources.forEach((sourceName, i) => {
                    const uniqueSideId = `${rxnId}_side_in_${sourceName}_${i}`;
                    // [ä¿®æ”¹] ä¼ å…¥ sub-reactant
                    addSideNode(uniqueSideId, sourceName, 'sub-reactant', rxnId, 'in', pathway, sheetName);

                    elements.push({
                        data: {
                            source: uniqueSideId, target: rxnId, 
                            pathway: pathway, type: 'in', edgeType: 'side' // type='in'
                        },
                        classes: 'edge-side hidden-side' });
                });

                // --- å¤„ç†å‡ºè¾¹ (Output) ---

                // Main Targets
                mainTargets.forEach(targetName => {
                    const tgtId = makeCompartmentNodeId(targetName, compKey);
                    addMainNode(targetName, compKey, sheetName, pathway);
                    elements.push({
                        data: { 
                            source: rxnId, target: tgtId, 
                            pathway: pathway, type: 'out', edgeType: 'main' // type='out'
                        },
                        classes: 'edge-main'
                    });
                });

                // Side Targets (å‰¯ç”Ÿæˆç‰©) -> æµ…ç´«è‰²
                sideTargets.forEach((targetName, i) => {
                    const uniqueSideId = `${rxnId}_side_out_${targetName}_${i}`;
                    // [ä¿®æ”¹] ä¼ å…¥ sub-product
                    addSideNode(uniqueSideId, targetName, 'sub-product', rxnId, 'out', pathway, sheetName);

                    elements.push({
                        data: { 
                            source: rxnId, target: uniqueSideId, 
                            pathway: pathway, type: 'out', edgeType: 'side' // type='out'
                        },
                        classes: 'edge-side hidden-side' });
                });
            }
        });

        // å›å¡«ä¸»å¹²åˆ†å­çš„é»˜è®¤é¢œè‰²ï¼ˆæŒ‰ sheet ä¼˜å…ˆçº§ï¼‰
        elements.forEach(el => {
            if (el && el.classes && String(el.classes).includes('main-molecule')) {
                const meta = mainMoleculeMeta.get(el.data.id);
                if (meta) {
                    el.data.color = pickSheetColor(meta.sheets);
                }
            }
        });

        generateCheckboxes(pathwaysBySheet);

        // --- æ–°å¢ï¼šåŒååˆ†å­åœ¨ä¸åŒç»†èƒå™¨ä¹‹é—´çš„â€œè½¬è¿â€è¿çº¿ ---
        // è§„åˆ™ï¼šè‹¥åŒä¸€ baseName åœ¨å¤šä¸ª compartment èŠ‚ç‚¹å‡ºç°ï¼Œåˆ™ä»ç¬¬ä¸€ä¸ªå‡ºç°çš„èŠ‚ç‚¹ä½œä¸º hubï¼Œè¿æ¥åˆ°å…¶ä»– compartment èŠ‚ç‚¹
        const safeKey = (s) => String(s).toLowerCase().replace(/[^a-z0-9_]/g, '_');
        moleculeCompNodes.forEach((nodeIds, baseName) => {
            const uniq = Array.from(new Set(nodeIds)).filter(Boolean);
            if (uniq.length <= 1) return;

            const hub = uniq[0];
            const baseSafe = safeKey(baseName);
            for (let i = 1; i < uniq.length; i++) {
                const other = uniq[i];
                const eid = `transport__${baseSafe}__${i}`;
                elements.push({
                    data: {
                        id: eid,
                        source: hub,
                        target: other,
                        edgeType: 'transport',
                        baseName: baseName
                    },
                    classes: 'edge-transport'
                });
            }
        });

        updateStatus(`æ˜¾ç¤ºæ•°æ®: ${elements.length} ä¸ªå…ƒç´ `);
        drawCytoscape(elements);
    }

    // ============================================================
    // 2. Cytoscape ç»˜å›¾ä¸å¸ƒå±€ (Draw & Layout)
    // ============================================================
    function drawCytoscape(allElements) {
        const container = document.getElementById('cy');
        const progressBar = document.getElementById('progress-bar');
        const progressText = document.getElementById('progress-text');
        const loadingMask = document.getElementById('loading-mask');

        // 1. åˆå§‹åŒ–ç©ºå›¾è¡¨
        window.cyGraph = cytoscape({
            container: container,
            // é™åˆ¶æ»šè½®ç¼©æ”¾é€Ÿåº¦ï¼Œé˜²æ­¢ä¸€æ»šè½®å›¾ä¹Ÿæ²¡äº†
            wheelSensitivity: 0.2, 
                    style: [
            // -----------------------------------------------------
            // 1. åŸºç¡€é»˜è®¤å€¼
            // -----------------------------------------------------
            {
                selector: 'node',
                style: {
                    'label': 'data(label)',
                    'text-valign': 'center', 'text-halign': 'center',
                    'font-size': '12px', 'color': '#fff',
                    'text-wrap': 'wrap',
                    'border-width': 0, // é»˜è®¤æ— è¾¹æ¡†
                    'shape': 'round-rectangle',
                    'width': 'label', 'height': 'label', 'padding': '8px'
                }
            },
            {
                selector: 'edge',
                style: {
                    'width': 2,
                    'curve-style': 'bezier'
                }
            },

            // -----------------------------------------------------
            // 2. èŠ‚ç‚¹é…è‰² (æ ¹æ®æ‚¨è¦æ±‚çš„é¢œè‰²)
            // -----------------------------------------------------
            
            // ã€ä¸»è¦ååº”ç‰©/äº§ç‰©ã€‘ï¼šç»¿è‰²èƒŒæ™¯ï¼Œæ— è¾¹æ¡†
            {
                selector: '.main-molecule',
                style: {
                    'background-color': 'data(color)', // ç”± sheet å†³å®š
                    'font-weight': 'bold',
                    'color': '#fff'
                }
            },

            // ã€å‰¯ååº”ç‰©ã€‘ï¼šæµ…è“è‰²èƒŒæ™¯ï¼Œæ— è¾¹æ¡†
            {
                selector: '.sub-reactant',
                style: {
                    'background-color': '#74b9ff', // æµ…è“
                    'font-size': '10px',
                    'padding': '5px'
                }
            },

            // ã€å‰¯ç”Ÿæˆç‰©ã€‘ï¼šæµ…ç´«è‰²èƒŒæ™¯ï¼Œæ— è¾¹æ¡†
            {
                selector: '.sub-product',
                style: {
                    'background-color': '#a29bfe', // æµ…ç´«
                    'font-size': '10px',
                    'padding': '5px'
                }
            },
            // ã€éšè—çš„å‰¯å°åˆ†å­/å‰¯è¿çº¿ã€‘ï¼šé»˜è®¤ä¸æ˜¾ç¤º
            {
                selector: '.hidden-side',
                style: {
                    'display': 'none'
                }
            },


            // ã€é…¶/ååº”èŠ‚ç‚¹ã€‘ï¼šæ— èƒŒæ™¯ï¼Œæµ…ç»¿è‰²è¾¹æ¡†
            {
                // ä½¿ç”¨ type é€‰æ‹©å™¨æˆ–è€… class é€‰æ‹©å™¨
                selector: 'node[type="reaction"]',
                style: {
                    'background-color': '#e5e5e5', // æµ…ç°è‰²èƒŒæ™¯
                    'background-opacity': 1,
                    'border-width': 0,
                    'color': '#000',               // é»‘è‰²å­—ä½“
                    'font-weight': 'normal',         // åŠ ç²—
                    'shape': 'ellipse',
                    'font-size': '11px',
                    'width': 'label', 'height': 'label', 'padding': '6px'
                }
            },

            // -----------------------------------------------------
            // 3. è¿çº¿é…è‰²ä¸ç®­å¤´ (é€»è¾‘æ ¸å¿ƒ)
            // -----------------------------------------------------

            // ã€æŒ‡å‘ååº”èŠ‚ç‚¹çš„è¾¹ (In)ã€‘ï¼šæµ…ç»¿è‰²ï¼Œæ— ç®­å¤´
            // åŒ¹é… data.type === 'in'
            {
                selector: 'edge[type="in"]',
                style: {
                    'line-color': '#C0C0C0',       // æµ…ç»¿è‰²
                    'target-arrow-shape': 'none',  // æ— ç®­å¤´
                    'width': 4           // çº¿æ›´ç²—ï¼Œç®­å¤´ä¹Ÿä¼šæ›´â€œæœ‰å­˜åœ¨æ„Ÿâ€
                }
            },

            // ã€ç¦»å¼€ååº”èŠ‚ç‚¹çš„è¾¹ (Out)ã€‘ï¼šç»¿è‰²ï¼Œæœ‰ç®­å¤´
            // åŒ¹é… data.type === 'out'
            {
                selector: 'edge[type="out"]',
                style: {
                    'line-color': '#CDCDCD',       // ç»¿è‰²
                    'target-arrow-shape': 'triangle', // ä¸‰è§’å½¢ç®­å¤´
                    'target-arrow-color': '#CDCDCD',
                    'arrow-scale': 1.6,   // è°ƒå¤§ç®­å¤´ï¼ˆé»˜è®¤å¤§æ¦‚æ˜¯ 1ï¼‰
                    'width': 4            // çº¿æ›´ç²—ï¼Œç®­å¤´ä¹Ÿä¼šæ›´â€œæœ‰å­˜åœ¨æ„Ÿâ€
                }
            },

            

            // ã€ç»†èƒå™¨è½¬è¿è¾¹ (Transport)ã€‘ï¼šç°è‰²è™šçº¿ï¼Œæ— ç®­å¤´ï¼ˆåŒååˆ†å­ä¸åŒç»†èƒå™¨ä¹‹é—´ï¼‰
            {
                selector: '.edge-transport',
                style: {
                    'line-color': '#CDCDCD',
                    'line-style': 'dashed',
                    'width': 1,
                    'target-arrow-shape': 'none',
                    'opacity': 1.0
                }
            },
// -----------------------------------------------------
            // 4. äº¤äº’é«˜äº®æ ·å¼ (ä¿æŒåŸæœ‰çš„åŠŸèƒ½)
            // -----------------------------------------------------
            {
                selector: ':selected',
                style: {
                    'background-color': '#e17055',
                    'line-color': '#e17055',
                    'target-arrow-color': '#e17055'
                }
            },
            {
                selector: '.dimmed',
                style: { 'opacity': 0.1, 'z-index': 0 }
            },
            {
                selector: '.highlighted',
                style: {
                    'opacity': 1,
                    // 'border-width': 3,
                    // 'border-color': '#d63031', // æœç´¢é«˜äº®çº¢æ¡†
                    'z-index': 999
                }
            }
        ],

            // åˆå§‹æ”¾å®½é™åˆ¶ï¼Œé˜²æ­¢å¸ƒå±€è®¡ç®—æ—¶è¢«å¡ä½
            minZoom: 1e-50,
            maxZoom: 1e50,
            zoomingEnabled: true,
            panningEnabled: true,
            layout: { name: 'preset' }, // åˆå§‹ä¸è®¡ç®—å¸ƒå±€
            elements: [] 
        });

        // ==========================================
        // å…³é”®ä¿®å¤ï¼šåˆ†ç¦» èŠ‚ç‚¹(Node) å’Œ è¿çº¿(Edge)
        // ==========================================
        const allNodes = [];
        const edgesByPathway = {};
        const pathwayNames = [];

        allElements.forEach(ele => {
            // åˆ¤æ–­æ˜¯å¦ä¸ºèŠ‚ç‚¹ï¼ˆgroupä¸å†™é»˜è®¤æ˜¯nodesï¼Œæˆ–è€…åˆ¤æ–­ data.source æ˜¯å¦å­˜åœ¨ï¼‰
            // Cytoscape JSON ä¸­ï¼Œè¿çº¿é€šå¸¸æœ‰ data.source å’Œ data.target
            if (ele.group === 'nodes' || (!ele.data.source && !ele.data.target)) {
                allNodes.push(ele);
            } else {
                // è¿™æ˜¯ä¸€ä¸ªè¿çº¿ (Edge)
                const p = ele.data.pathway || 'Other';
                if (!edgesByPathway[p]) {
                    edgesByPathway[p] = [];
                    pathwayNames.push(p); // è®°å½•é€šè·¯å
                }
                edgesByPathway[p].push(ele);
            }
        });

        // 2. ç¬¬ä¸€æ­¥ï¼šå®‰å…¨æ·»åŠ æ‰€æœ‰èŠ‚ç‚¹ (ä¸ä¼šæŠ¥é”™ï¼Œå› ä¸ºèŠ‚ç‚¹ä¸ä¾èµ–åˆ«äºº)
        // ä¸ºäº†é˜²æ­¢ä¸€å¼€å§‹ä¹Ÿæ˜¯ä¹±çš„ï¼Œæˆ‘ä»¬å¯ä»¥å…ˆåŠ è¿›å»ä½†ä¸é‡ç»˜ï¼Œæˆ–è€…é»˜é»˜åŠ è¿›å»
        window.cyGraph.add(allNodes);
        console.log(`å·²é¢„åŠ è½½ ${allNodes.length} ä¸ªèŠ‚ç‚¹ï¼Œé˜²æ­¢ä¾èµ–æŠ¥é”™ã€‚`);

        // 3. ç¬¬äºŒæ­¥ï¼šé€æ­¥åŠ è½½è¿çº¿ (åŠ¨ç”»è¿‡ç¨‹)
        let currentIndex = 0;

        function renderNextBatch() {
            try {
                // ç»“æŸæ¡ä»¶
                if (currentIndex >= pathwayNames.length) {
                    finishLoading();
                    return;
                }

                const pName = pathwayNames[currentIndex];
                const edgesBatch = edgesByPathway[pName];

                // æ›´æ–° UI
                const percent = Math.round(((currentIndex + 1) / pathwayNames.length) * 100);
                if(progressBar) progressBar.style.width = `${percent}%`;
                if(progressText) progressText.innerText = `æ­£åœ¨è¿æ¥: ${pName} (${currentIndex + 1}/${pathwayNames.length})`;

                // æ·»åŠ è¿™æ‰¹è¿çº¿
                if (edgesBatch && edgesBatch.length > 0) {
                    window.cyGraph.batch(() => {
                        window.cyGraph.add(edgesBatch);
                    });
                }

                currentIndex++;
                // ç»§ç»­ä¸‹ä¸€å¸§
                requestAnimationFrame(renderNextBatch);

            } catch (err) {
                console.error("åŠ è½½è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯ï¼Œè·³è¿‡è¯¥æ‰¹æ¬¡ç»§ç»­:", err);
                // å¦‚æœå‡ºé”™ï¼Œå¼ºåˆ¶ç»§ç»­ä¸‹ä¸€é¡¹ï¼Œé˜²æ­¢å¡æ­»
                currentIndex++;
                requestAnimationFrame(renderNextBatch);
            }
        }

        // 4. æ”¶å°¾å·¥ä½œ
                // 4. æ”¶å°¾å·¥ä½œ
        function finishLoading() {
            if(progressText) progressText.innerText = "Please Wait a Minute...";
            
            setTimeout(() => {
                // å°è¯•è‡ªåŠ¨æ¢å¤ä¸Šä¸€æ¬¡å¸ƒå±€ï¼ˆè‹¥æˆåŠŸï¼Œåˆ™ä½¿ç”¨ preset å¸ƒå±€é¿å…é‡æ’ï¼‰
                const restored = restoreLayoutAuto && restoreLayoutAuto();

                // å®šä¹‰å¸ƒå±€å‚æ•°
                const layoutConfig = {
                    name: restored ? 'preset' : 'dagre',
                    rankDir: 'TB', // ä»ä¸Šåˆ°ä¸‹
                    padding: 50,   // ç•™ç‚¹ç™½è¾¹
                    fit: true,     // å¸ƒå±€ç»“æŸåè®©å›¾å……æ»¡å±å¹•
                    animate: false // å…³é—­å¸ƒå±€åŠ¨ç”»ï¼Œç›´æ¥æ˜¾ç¤ºç»“æœ
                };

                const layout = window.cyGraph.layout(layoutConfig);

                // ã€æ ¸å¿ƒä¿®æ”¹ã€‘ç›‘å¬å¸ƒå±€ç»“æŸäº‹ä»¶
                layout.on('layoutstop', () => {
                    const cy = window.cyGraph;
                    // ç»‘å®šå‰¯å°åˆ†å­äº¤äº’ï¼ˆå¤šé€‰ï¼‰
                    bindSideInteractionsOnce();
                    // ==========================================
                    // ã€æ ¸å¿ƒä¿®æ”¹ã€‘åœ¨æ­¤å¤„è°ƒç”¨å¯¹é½å‡½æ•°
                    // ==========================================
                    refreshSideVisibility(); 
                    // ==========================================

                    // é‡æ–°é€‚é…è§†å›¾å¤§å° (å› ä¸ºèŠ‚ç‚¹ä½ç½®å˜äº†)
                    cy.fit(cy.elements(), 50);

                    // è‡ªåŠ¨ä¿å­˜ä¸€æ¬¡ï¼ˆåˆæ¬¡å¸ƒå±€/æ¢å¤å®Œæˆåï¼‰
                    autoSaveLayoutDebounced();

                    // 1. è·å–å½“å‰â€œå…¨å±å±•ç¤ºâ€æ—¶çš„ç¼©æ”¾æ¯”ä¾‹
                    // å› ä¸º fit:true å·²ç»æ‰§è¡Œï¼Œç°åœ¨çš„ zoom å°±æ˜¯åˆšå¥½èƒ½çœ‹å…¨çš„å¤§å°
                    const fitZoom = cy.zoom();

                    // 2. è®¾ç½®åŠ¨æ€ç¼©æ”¾é™åˆ¶
                    // æœ€å°åªå…è®¸ç¼©æ”¾åˆ°â€œå…¨å›¾çš„ä¸€åŠå¤§â€ï¼Œä¸èƒ½å†å°äº†
                    cy.minZoom(fitZoom * 1);
                    // æœ€å¤§å…è®¸æ”¾å¤§ 5 å€
                    cy.maxZoom(fitZoom * 50); // ä¹‹å‰çš„ maxZoom å¦‚æœæ˜¯å›ºå®šæ•°å­—å¯èƒ½ä¸å‡†ï¼Œç°åœ¨æ˜¯ç›¸å¯¹å€¼

                    // 3. è®¾ç½®å¹³ç§»é™åˆ¶ï¼ˆä¸è®©å›¾è·‘å‡ºå±å¹•ï¼‰
                    // ç»‘å®š viewport äº‹ä»¶ï¼Œæ¯æ¬¡ç”¨æˆ·æ‹–æ‹½/ç¼©æ”¾æ—¶æ£€æŸ¥
                    cy.on('viewport', function() {
                        const pan = cy.pan();
                        const zoom = cy.zoom();
                        const width = cy.width();
                        const height = cy.height();
                        
                        // è·å–æ•´ä¸ªå›¾å…¶å®é™…å æ®çš„ç‰©ç†èŒƒå›´
                        const bb = cy.elements().boundingBox();
                        
                        // è®¡ç®—è¾¹ç•Œï¼ˆå…è®¸ç•™ç™½ä¸€ç‚¹ç‚¹ï¼Œä½†ä¸å…è®¸å®Œå…¨è·‘å‡ºå»ï¼‰
                        // ä¸‹é¢çš„é€»è¾‘ç¡®ä¿å›¾çš„è¾¹ç¼˜è‡³å°‘æœ‰ä¸€éƒ¨åˆ†åœ¨å±å¹•å†…
                        const gutter = 100; // ç¼“å†²åŒºåƒç´ 

                        // ç®€å•çš„â€œå›å¼¹â€é€»è¾‘ä¼šé€ æˆæŠ–åŠ¨ï¼Œæ‰€ä»¥æˆ‘ä»¬åªé™åˆ¶èŒƒå›´
                        // ä¸‹é¢æ˜¯æ¯”è¾ƒé€šç”¨çš„é™åˆ¶é€»è¾‘ï¼Œä¸éœ€è¦æ·±ç©¶æ•°å­¦åŸç†
                        // æ ¸å¿ƒæ€æƒ³ï¼šå¦‚æœPanå¾—å¤ªè¿œï¼Œå°±å¼ºåˆ¶æ‹‰å›æ¥
                        
                        // è®¡ç®—åˆæ³•çš„ Pan èŒƒå›´
                        // è¿™é‡Œçš„é€»è¾‘ç¨å¾®å¤æ‚ï¼Œç›®çš„æ˜¯è®©å›¾çš„å†…å®¹å§‹ç»ˆä¿ç•™åœ¨ viewport å†…
                        
                        // ç®€æ˜“ç‰ˆé™åˆ¶ï¼šé™åˆ¶å›¾çš„ä¸­å¿ƒç‚¹ä¸èƒ½è·‘å‡ºå±å¹•
                        const graphCenterX = (bb.x1 + bb.w/2) * zoom + pan.x;
                        const graphCenterY = (bb.y1 + bb.h/2) * zoom + pan.y;
                        
                        // å¦‚æœä¸­å¿ƒç‚¹è·‘å¤ªè¿œäº†ï¼Œå°±å¼ºè¡Œé‡ç½® Pan
                        // è¿™é‡Œä¸åšå¼ºåˆ¶è¦†ç›–ï¼ŒCytoscape æ²¡æœ‰å†…ç½® bounds é™åˆ¶
                        // è¿™æ˜¯ä¸€ä¸ªæŠ˜ä¸­æ–¹æ¡ˆï¼šå¦‚æœæ£€æµ‹åˆ°è¿ boundingbox éƒ½çœ‹ä¸åˆ°äº†ï¼Œå°± fit å›å»
                        // ä½†è¿™ä½“éªŒä¸å¥½ã€‚
                    });
                    
                    // ã€å¼ºçƒˆæ¨èã€‘ä½¿ç”¨ containment é€»è¾‘ä»£æ›¿ä¸Šé¢çš„æ‰‹åŠ¨è®¡ç®—
                    // Cytoscape æ²¡æœ‰å†…ç½® containmentï¼Œæœ€ç¨³å¦¥çš„æ–¹æ³•æ˜¯é™åˆ¶ minZoom (ä¸Šé¢å·²åš)
                    // åªè¦ minZoom è¶³å¤Ÿå¤§ï¼Œç”¨æˆ·å°±æ°¸è¿œæ— æ³•æŠŠå›¾å˜å¼„ä¸¢ã€‚
                    
                    // ç§»é™¤é®ç½©
                    if(loadingMask) {
                        loadingMask.style.opacity = '0';
                        setTimeout(() => {
                            loadingMask.style.display = 'none';
                        }, 500);
                    }
                });

                layout.run();
                
                if(typeof initSearchListener === 'function') initSearchListener();
            }, 100);
        }


        // å¯åŠ¨å¾ªç¯
        renderNextBatch();
    }




    // ============================================================
    // 3. æ ¸å¿ƒç®—æ³•ï¼šç²¾ç¡®å‡ ä½•å®šä½ + æ··åˆçº¿å‹ (recalculateCurves)
    // ============================================================
    const recalculateCurves = () => {
        const currentCy = window.cyGraph || window.cy;
        if (!currentCy) return;

        currentCy.batch(() => {
            // å‚æ•°é…ç½®
            const GAP_X = 25;      // å‰¯èŠ‚ç‚¹ä¸ä¸»èŠ‚ç‚¹è¾¹ç¼˜çš„é—´è·
            const STEP_Y = 40;     // å‰¯èŠ‚ç‚¹çš„å‚ç›´å¯¹é½æ­¥é•¿

            currentCy.nodes('[type="reaction"]').forEach(rxnNode => {
                const center = rxnNode.position(); 
                const rxnW = rxnNode.outerWidth();
                
                // --- 1. å®šä½å·¦ä¾§å‰¯ååº”ç‰© (Side Inputs) ---
                const sideInEdges = rxnNode.incomers('edge[edgeType="side"]');
                const sideInNodes = sideInEdges.sources();
                
                if (sideInNodes.length > 0) {
                    const totalHeight = (sideInNodes.length - 1) * STEP_Y;
                    const startY = center.y - (totalHeight / 2);

                    sideInNodes.forEach((node, i) => {
                        const nodeW = node.outerWidth(); 
                        // å…¬å¼ï¼šCenter - RxnHalf - Gap - NodeHalf
                        const targetX = center.x - (rxnW / 2) - GAP_X - (nodeW / 2);
                        node.position({ x: targetX, y: startY + (i * STEP_Y) });
                    });
                }

                // --- 2. å®šä½å³ä¾§å‰¯äº§ç‰© (Side Outputs) ---
                const sideOutEdges = rxnNode.outgoers('edge[edgeType="side"]');
                const sideOutNodes = sideOutEdges.targets();

                if (sideOutNodes.length > 0) {
                    const totalHeight = (sideOutNodes.length - 1) * STEP_Y;
                    const startY = center.y - (totalHeight / 2);

                    sideOutNodes.forEach((node, i) => {
                        const nodeW = node.outerWidth();
                        // å…¬å¼ï¼šCenter + RxnHalf + Gap + NodeHalf
                        const targetX = center.x + (rxnW / 2) + GAP_X + (nodeW / 2);
                        node.position({ x: targetX, y: startY + (i * STEP_Y) });
                    });
                }

                // --- 3. è®¡ç®—ä¸»å¹²æµå‘å‘é‡ (Main Flow Vector) ---
                const mainInEdges = rxnNode.incomers('edge[edgeType="main"]');
                const mainOutEdges = rxnNode.outgoers('edge[edgeType="main"]');

                // é»˜è®¤å‘é‡ (0,1) å‘ä¸‹
                let flowVec = { x: 0, y: 1 }; 

                // åªæœ‰ä¸»å¹²æ‰å‚ä¸å‘é‡è®¡ç®—
                if (mainInEdges.length > 0 || mainOutEdges.length > 0) {
                    const getCentroid = (edges, type) => {
                        let x = 0, y = 0;
                        if (edges.length === 0) return center;
                        edges.forEach(e => {
                            const p = type === 'in' ? e.source().position() : e.target().position();
                            x += p.x; y += p.y;
                        });
                        return { x: x / edges.length, y: y / edges.length };
                    };

                    const upstreamP = getCentroid(mainInEdges, 'in');
                    const downstreamP = getCentroid(mainOutEdges, 'out');

                    let dx = downstreamP.x - upstreamP.x;
                    let dy = downstreamP.y - upstreamP.y;
                    const len = Math.sqrt(dx * dx + dy * dy);

                    if (len > 0.1) {
                        flowVec = { x: dx / len, y: dy / len };
                    }
                }

                // --- 4. åˆ†ç±»åº”ç”¨æ ·å¼ ---
                
                // è´å¡å°”æ§åˆ¶ç‚¹è®¡ç®—å‡½æ•°
                const calcBezierDist = (pStart, pEnd) => {
                    const mid = { x: (pStart.x + pEnd.x)/2, y: (pStart.y + pEnd.y)/2 };
                    const seg = { x: pEnd.x - pStart.x, y: pEnd.y - pStart.y };
                    const perp = { x: -seg.y, y: seg.x }; // å‚ç›´å‘é‡
                    const perpLen = Math.sqrt(perp.x*perp.x + perp.y*perp.y);
                    if (perpLen < 0.01) return 0;
                    const perpNorm = { x: perp.x/perpLen, y: perp.y/perpLen };

                    // æŠ•å½±
                    const a1 = perpNorm.x, b1 = -flowVec.x, c1 = center.x - mid.x;
                    const a2 = perpNorm.y, b2 = -flowVec.y, c2 = center.y - mid.y;
                    const det = a1 * b2 - a2 * b1;
                    
                    if (Math.abs(det) < 0.001) return 0;
                    let dist = (c1 * b2 - c2 * b1) / det;
                    
                    if (Math.abs(dist) > 300) dist = dist > 0 ? 300 : -300;
                    return Math.abs(dist) < 2 ? 0 : dist;
                };

                // å¤„ç†å…¥è¾¹
                rxnNode.incomers('edge').forEach(edge => {
                    if (edge.data('edgeType') === 'main') {
                        const dist = calcBezierDist(edge.source().position(), center);
                        edge.style({
                            'curve-style': 'unbundled-bezier',
                            'control-point-distances': dist,
                            'control-point-weights': 0.5 
                        });
                    } else {
                        // å‰¯ååº”ï¼šç›´çº¿
                        edge.style({
                            'curve-style': 'straight', 
                            'target-arrow-shape': 'none' 
                        });
                    }
                });

                // å¤„ç†å‡ºè¾¹
                rxnNode.outgoers('edge').forEach(edge => {
                    if (edge.data('edgeType') === 'main') {
                        const dist = calcBezierDist(center, edge.target().position());
                        edge.style({
                            'curve-style': 'unbundled-bezier',
                            'control-point-distances': dist,
                            'control-point-weights': 0.5
                        });
                    } else {
                        // å‰¯ååº”ï¼šç›´çº¿
                        edge.style({
                            'curve-style': 'straight'
                        });
                    }
                });
            });
        });
    };

    // ============================================================
    // 4. å³ä¾§ç­›é€‰é€»è¾‘ (Filter)
    // ============================================================
    function generateCheckboxes(pathwaysBySheet) {
        const container = document.getElementById('filter-container');
        container.innerHTML = '';

        // Global Select All
        const globalDiv = document.createElement('label');
        globalDiv.className = 'checkbox-item';
        globalDiv.innerHTML = `<input type="checkbox" id="check-all-global" checked> <b>(Select All)</b>`;
        container.appendChild(globalDiv);

        // Clear selected side-molecules (only from reaction selection)
        const clearBtn = document.createElement('button');
        clearBtn.id = 'clear-selected-side';
        clearBtn.className = 'side-action-btn';
        clearBtn.textContent = 'Clear selected molecules';
        clearBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (window.selectedReactionIds) window.selectedReactionIds.clear();
            refreshSideVisibility();
        });
        container.appendChild(clearBtn);


        const buildSheetGroup = (sheetName) => {
            const group = document.createElement('div');
            group.className = 'sheet-group';

            const header = document.createElement('div');
            header.className = 'sheet-header';
            header.innerHTML = `
                <div class="sheet-name">
                    <span class="sheet-swatch" style="background:${SHEET_COLORS[sheetName] || '#95a5a6'}"></span>
                    <span>${sheetName}</span>
                </div>
            `;

            const selectAll = document.createElement('label');
            selectAll.className = 'checkbox-item sheet-selectall';
            selectAll.innerHTML = `<input type="checkbox" class="check-all-sheet" data-sheet="${sheetName}" checked> <b>(Select All)</b>`;
            header.appendChild(selectAll);

            const body = document.createElement('div');
            body.className = 'sheet-body';

            group.appendChild(header);
            group.appendChild(body);

            return { group, body, selectAllInput: selectAll.querySelector('input') };
        };

        // Render groups in TARGET_SHEETS order
        const sheetGroups = new Map();
        TARGET_SHEETS.forEach(sheet => {
            const { group, body, selectAllInput } = buildSheetGroup(sheet);
            sheetGroups.set(sheet, { body, selectAllInput });
            container.appendChild(group);
        });

        // Fill pathways (keep sheet order as collected)
        TARGET_SHEETS.forEach(sheet => {
            const list = (pathwaysBySheet && pathwaysBySheet.get) ? (pathwaysBySheet.get(sheet) || []) : [];
            const { body } = sheetGroups.get(sheet) || {};
            if (!body) return;

            if (!list || list.length === 0) {
                const empty = document.createElement('div');
                empty.style.cssText = 'color:#999;font-size:12px;padding:4px 6px;font-style:italic;';
                empty.textContent = 'ï¼ˆæ—  Pathwayï¼‰';
                body.appendChild(empty);
                return;
            }

            list.forEach(pw => {
                const label = document.createElement('label');
                label.className = 'checkbox-item';
                label.innerHTML = '';
                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.className = 'pw-check';
                cb.value = pw;
                cb.dataset.sheet = sheet;
                cb.checked = true;

                const text = document.createElement('span');
                text.className = 'pw-text';
                text.textContent = pw;

                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'side-toggle-btn';
                btn.dataset.pathway = pw;
                btn.textContent = 'Demonstrate currency';
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const p = btn.dataset.pathway;
                    if (!window.pinnedSidePathways) window.pinnedSidePathways = new Set();
                    if (window.pinnedSidePathways.has(p)) {
                        window.pinnedSidePathways.delete(p);
                        btn.classList.remove('active');
                    } else {
                        window.pinnedSidePathways.add(p);
                        btn.classList.add('active');
                    }
                    refreshSideVisibility();
                });

                label.appendChild(cb);
                label.appendChild(text);
                label.appendChild(btn);
                body.appendChild(label);
            });
        });

        const allPwChecks = () => Array.from(container.querySelectorAll('.pw-check'));
        const updateGlobalState = () => {
            const boxes = allPwChecks();
            const allChecked = boxes.length > 0 && boxes.every(cb => cb.checked);
            document.getElementById('check-all-global').checked = allChecked;
        };
        const updateSheetState = (sheet) => {
            const boxes = allPwChecks().filter(cb => cb.dataset.sheet === sheet);
            const allChecked = boxes.length > 0 && boxes.every(cb => cb.checked);
            const g = sheetGroups.get(sheet);
            if (g && g.selectAllInput) g.selectAllInput.checked = allChecked;
        };

        // Bind global select all
        globalDiv.querySelector('input').addEventListener('change', (e) => {
            const isChecked = e.target.checked;
            allPwChecks().forEach(cb => cb.checked = isChecked);
            TARGET_SHEETS.forEach(updateSheetState);
            filterGraph();
        });

        // Bind per-sheet select all
        TARGET_SHEETS.forEach(sheet => {
            const g = sheetGroups.get(sheet);
            if (!g) return;
            g.selectAllInput.addEventListener('change', (e) => {
                const isChecked = e.target.checked;
                allPwChecks()
                    .filter(cb => cb.dataset.sheet === sheet)
                    .forEach(cb => cb.checked = isChecked);
                updateGlobalState();
                filterGraph();
            });
        });

        // Bind per-pathway
        allPwChecks().forEach(cb => {
            cb.addEventListener('change', () => {
                updateSheetState(cb.dataset.sheet);
                updateGlobalState();
                filterGraph();
            });
        });

        // Initial state
        TARGET_SHEETS.forEach(updateSheetState);
        updateGlobalState();
        setTimeout(filterGraph, 100);
    }


    
    // æ ¹æ®å½“å‰é€‰ä¸­çš„ Pathwayï¼ŒåŠ¨æ€åˆ·æ–°ä¸»å¹²åˆ†å­ï¼ˆMain Reactant / Main Productï¼‰çš„é¢œè‰²
    function updateMainMoleculeColors(selectedPathways) {
        const cy = window.cyGraph || window.cy;
        const metaMap = window.mainMoleculeMeta;
        if (!cy || !metaMap) return;

        cy.nodes('.main-molecule').forEach(n => {
            const meta = metaMap.get(n.data('baseName') || n.id());
            if (!meta) return;

            // è‹¥é€‰ä¸­äº† Pathwayï¼šä¼˜å…ˆç”¨è¯¥åˆ†å­åœ¨â€œè¢«é€‰ä¸­ Pathwayâ€å¯¹åº”çš„ sheet é¢œè‰²
            if (selectedPathways && selectedPathways.length > 0) {
                const candidate = new Set();
                selectedPathways.forEach(pw => {
                    const sset = meta.pathwaySheets.get(pw);
                    if (sset) sset.forEach(s => candidate.add(s));
                });
                if (candidate.size > 0) {
                    n.data('color', pickSheetColor(candidate));
                    return;
                }
            }

            // å¦åˆ™ï¼šæŒ‰åˆ†å­å…¨å±€å‡ºç°çš„ sheets å–é»˜è®¤é¢œè‰²ï¼ˆæŒ‰ä¼˜å…ˆçº§ï¼‰
            n.data('color', pickSheetColor(meta.sheets));
        });
    }

function filterGraph() {
        const currentCy = window.cyGraph || window.cy;
        if (!currentCy) return;

        const checkboxes = document.querySelectorAll('.pw-check');
        const selectedPathways = Array.from(checkboxes)
            .filter(cb => cb.checked)
            .map(cb => cb.value);

        // è®°å½•å½“å‰å‹¾é€‰çš„ pathwayï¼ˆå‰¯å°åˆ†å­æ˜¾ç¤ºä¹Ÿéœ€è¦ç”¨åˆ°ï¼‰
        window.__selectedPathwaysSet = new Set(selectedPathways);

        currentCy.batch(() => {
            const allElements = currentCy.elements();
            allElements.removeClass('highlighted').addClass('dimmed');

            if (selectedPathways.length === 0) {
                // é¢œè‰²å›é€€åˆ°é»˜è®¤ï¼ˆæŒ‰åˆ†å­å…¨å±€å‡ºç°çš„ sheetsï¼‰
                updateMainMoleculeColors([]);
                return;
            }

            const activeEdges = currentCy.edges().filter(edge => {
                const pData = edge.data('pathway');
                if (!pData) return false;
                return selectedPathways.includes(pData);
            });

            activeEdges.removeClass('dimmed').addClass('highlighted');
            activeEdges.connectedNodes().removeClass('dimmed').addClass('highlighted');

            // åŒæ­¥åˆ·æ–°ä¸»å¹²åˆ†å­é¢œè‰²ï¼ˆé€‰ä¸­ Pathway æ—¶æŒ‰è¯¥ Pathway æ‰€å± sheet ä¸Šè‰²ï¼‰
            updateMainMoleculeColors(selectedPathways);
        });

        // ä¾§è¾¹æ ç­›é€‰å˜åŒ–åï¼Œæ›´æ–°å‰¯å°åˆ†å­æ˜¾ç¤º
        refreshSideVisibility();

    }

    // è¾…åŠ©å·¥å…·
    function showStatus(msg) { document.getElementById('status').innerText = msg; }
    function updateStatus(text) { document.getElementById('status').innerText = text; }

    // ============================================================
    // 4b. å‰¯å°åˆ†å­æ˜¾ç¤ºé€»è¾‘ï¼šé»˜è®¤éšè—ï¼ŒæŒ‰éœ€å›´ç»•é…¶èŠ‚ç‚¹å±•å¼€
    // ============================================================
    function refreshSideVisibility() {
        const cy = window.cyGraph;
        if (!cy) return;

        const selectedPathways = window.__selectedPathwaysSet || new Set();
        const pinned = window.pinnedSidePathways || new Set();
        const selectedRxns = window.selectedReactionIds || new Set();

        cy.batch(() => {
            // å…ˆå…¨éƒ¨éšè—
            cy.nodes('.side-molecule').addClass('hidden-side');
            cy.edges('.edge-side').addClass('hidden-side');

            // å†æŒ‰â€œå›ºå®šæ‰“å¼€çš„ pathwayâ€æ˜¾ç¤º
            cy.nodes('[type="reaction"]').forEach(rxn => {
                const pw = rxn.data('pathway');
                if (!pw) return;
                // åªåœ¨è¯¥ pathway ä»ç„¶è¢«å‹¾é€‰æ—¶å±•å¼€ï¼ˆé¿å…ä¸è¿‡æ»¤å†²çªï¼‰
                if (pinned.has(pw) && (selectedPathways.size === 0 || selectedPathways.has(pw))) {
                    showSideForReaction(rxn.id());
                }
            });

            // å†æŒ‰â€œç‚¹é€‰çš„ååº”â€æ˜¾ç¤ºï¼ˆå…è®¸å¤šä¸ªå…±å­˜ï¼‰
            selectedRxns.forEach(rxnId => {
                showSideForReaction(rxnId);
            });
        });

        // æ˜¾ç¤ºåå†ç»Ÿä¸€å¯¹é½ï¼Œé¿å…æ•£è½/é‡å 
        alignSideNodes();
    }

    function showSideForReaction(rxnId) {
        const cy = window.cyGraph;
        if (!cy) return;

        // side nodes çš„ id éƒ½ä»¥ `${rxnId}_side_` å¼€å¤´
        cy.nodes('.side-molecule').forEach(n => {
            if (n.id().startsWith(`${rxnId}_side_`)) {
                n.removeClass('hidden-side');
            }
        });

        // side edgesï¼šè¿æ¥ååº”èŠ‚ç‚¹ä¸ side node
        cy.edges('.edge-side').forEach(e => {
            const s = e.data('source');
            const t = e.data('target');
            if ((typeof s === 'string' && s.startsWith(`${rxnId}_side_`)) ||
                (typeof t === 'string' && t.startsWith(`${rxnId}_side_`))) {
                e.removeClass('hidden-side');
            }
        });
    }

    function bindSideInteractionsOnce() {
        const cy = window.cyGraph;
        if (!cy) return;
        if (cy.__sideBound) return;
        cy.__sideBound = true;

        // ç‚¹é€‰ååº”/é…¶èŠ‚ç‚¹ï¼šæ”¯æŒå¤šé€‰ï¼Œä¸ä¼šè®©ä¹‹å‰çš„æ¶ˆå¤±
        cy.on('tap', 'node[type="reaction"]', (evt) => {
            const id = evt.target.id();
            if (!window.selectedReactionIds) window.selectedReactionIds = new Set();
            if (window.selectedReactionIds.has(id)) window.selectedReactionIds.delete(id);
            else window.selectedReactionIds.add(id);
            refreshSideVisibility();
            autoSaveLayoutDebounced();
        });

        // æ‹–åŠ¨ååº”èŠ‚ç‚¹æ—¶ï¼Œå‰¯å°åˆ†å­è·Ÿéšæ’å¸ƒ
        let _raf = null;
        cy.on('drag', 'node[type="reaction"]', () => {
            if (_raf) cancelAnimationFrame(_raf);
            _raf = requestAnimationFrame(() => alignSideNodes());
        });
        cy.on('dragfree', 'node', () => {
            alignSideNodes();
            autoSaveLayoutDebounced();
        });
    }

    // ============================================================
    // 4c. è‡ªåŠ¨ä¿å­˜/æ¢å¤å¸ƒå±€ï¼ˆé¿å…æ¯æ¬¡éƒ½é‡è°ƒä½ç½®ï¼‰
    // ============================================================
    const STORAGE_KEY_AUTO = STORAGE_KEY + '_autosave';

    function saveLayoutAuto() {
        if (!window.cyGraph) return;
        const positions = {};
        window.cyGraph.nodes().forEach(node => {
            positions[node.id()] = node.position();
        });
        localStorage.setItem(STORAGE_KEY_AUTO, JSON.stringify(positions));
    
        saveLayoutToServer(positions);
}

    function restoreLayoutAuto() {
        const raw = localStorage.getItem(STORAGE_KEY_AUTO);
        if (!raw || !window.cyGraph) return false;
        let positions = null;
        try { positions = JSON.parse(raw); } catch { return false; }

        let hit = 0;
        window.cyGraph.nodes().forEach(node => {
            const p = positions[node.id()];
            if (p && typeof p.x === 'number' && typeof p.y === 'number') {
                node.position(p);
                hit += 1;
            }
        });
        return hit > 0;
    }

    let _saveTimer = null;
    function autoSaveLayoutDebounced() {
        if (_saveTimer) clearTimeout(_saveTimer);
        _saveTimer = setTimeout(() => {
            try { saveLayoutAuto(); } catch(e) {}
        }, 250);
    }

    window.addEventListener('beforeunload', () => {
        try { saveLayoutAuto(); } catch(e) {}
    });

function showError(msg) {
    const el = document.getElementById('error-msg');
    el.style.display = 'block';
    el.innerHTML = 'âŒ ' + msg;
}
// ... ä½ çš„å…¶ä»–ä»£ç  ...
    // ============================================================
    // 5. ã€æ–°å¢ã€‘å‰¯èŠ‚ç‚¹å¼ºåˆ¶å¯¹é½ç®—æ³• (è®©å‰¯äº§ç‰©ç´§è´´ååº”èŠ‚ç‚¹)
    // ============================================================
    function alignSideNodes() {
        const cy = window.cyGraph;
        if (!cy) return;

        cy.batch(() => {
            // æ›´ç¾è§‚çš„æ’å¸ƒï¼šè¿œç¦»é…¶èŠ‚ç‚¹ï¼Œä¸”å¤šå°åˆ†å­æ—¶é‡‡ç”¨â€œå¤šåˆ—æ …æ ¼â€
            const OFFSET_X = 160;    // æ¨ªå‘è·ç¦»ï¼šè®©å‡ºé…¶èŠ‚ç‚¹æ–‡å­—åŒºåŸŸ
            const STEP_Y  = 26;      // è¡Œé—´è·
            const MAX_PER_COL = 6;   // å•åˆ—æœ€å¤šæ”¾å¤šå°‘ä¸ª
            const COL_GAP = 70;      // å¤šåˆ—æ—¶åˆ—é—´è·

            const isVisibleSide = (n) => !n.hasClass('hidden-side');

            cy.nodes('[type="reaction"]').forEach(rxnNode => {
                const center = rxnNode.position();
                const rxnId = rxnNode.id();

                // åªå¤„ç†â€œå½“å‰å¯è§â€çš„å‰¯å°åˆ†å­
                const inNodes = [];
                const outNodes = [];

                cy.nodes('.side-molecule').forEach(n => {
                    if (!isVisibleSide(n)) return;
                    if (n.data('parentRxn') !== rxnId) return;
                    if (n.data('role') === 'in') inNodes.push(n);
                    if (n.data('role') === 'out') outNodes.push(n);
                });

                const placeGrid = (nodes, side) => {
                    const total = nodes.length;
                    if (total === 0) return;

                    const cols = Math.ceil(total / MAX_PER_COL);
                    for (let c = 0; c < cols; c++) {
                        const start = c * MAX_PER_COL;
                        const chunk = nodes.slice(start, start + MAX_PER_COL);
                        const rows = chunk.length;

                        // å·¦ä¾§å‘å·¦æ‰©å±•ï¼Œå³ä¾§å‘å³æ‰©å±•
                        const x = (side === 'left')
                            ? (center.x - OFFSET_X - c * COL_GAP)
                            : (center.x + OFFSET_X + c * COL_GAP);

                        const y0 = center.y - (rows - 1) * STEP_Y / 2;

                        chunk.forEach((node, r) => {
                            node.position({
                                x: x,
                                y: y0 + r * STEP_Y
                            });
                        });
                    }
                };

                // è¾“å…¥æ”¾å·¦è¾¹ï¼Œè¾“å‡ºæ”¾å³è¾¹
                placeGrid(inNodes, 'left');
                placeGrid(outNodes, 'right');
            });
        });
    }

// åœ¨è„šæœ¬æœ€åå¯åŠ¨ç›‘å¬
initSearchListener();

</script> </body> </html>